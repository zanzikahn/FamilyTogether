<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <title>Family Cleaning Tracker</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #f3f4f6; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .login-screen { min-height: 100vh; background: linear-gradient(135deg, #60a5fa, #a855f7); display: flex; align-items: center; justify-content: center; }
        .login-card { background: white; padding: 40px; border-radius: 20px; box-shadow: 0 20px 40px rgba(0,0,0,0.1); max-width: 400px; width: 100%; }
        .member-btn { width: 100%; padding: 15px; margin: 10px 0; background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 10px; cursor: pointer; display: flex; align-items: center; gap: 15px; transition: all 0.2s; }
        .member-btn:hover { background: #dbeafe; border-color: #3b82f6; }
        .admin-section { margin-top: 20px; padding-top: 20px; border-top: 1px solid #e5e7eb; display: flex; gap: 10px; }
        .admin-input { flex: 1; padding: 10px; border: 1px solid #d1d5db; border-radius: 5px; }
        .btn { padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer; font-weight: 500; transition: all 0.2s; }
        .btn-primary { background: #3b82f6; color: white; }
        .btn-primary:hover { background: #2563eb; }
        .btn-success { background: #10b981; color: white; }
        .btn-success:hover { background: #059669; }
        .btn-danger { background: #ef4444; color: white; }
        .btn-danger:hover { background: #dc2626; }
        .btn-secondary { background: #6b7280; color: white; }
        .btn-secondary:hover { background: #4b5563; }
        .btn-warning { background: #f59e0b; color: white; }
        .btn-warning:hover { background: #d97706; }
        .btn-small { padding: 5px 10px; font-size: 12px; }
        .task-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin: 20px 0; }
        .task-card { background: white; padding: 20px; border-radius: 10px; border: 2px solid #e5e7eb; transition: all 0.2s; }
        .task-card:hover { border-color: #3b82f6; }
        .task-card.pending { background: #fef3c7; border-color: #f59e0b; }
        .task-card.rejected { background: #fef2f2; border-color: #ef4444; }
        .task-header { display: flex; justify-content: space-between; align-items: start; margin-bottom: 15px; }
        .task-title { font-weight: 600; color: #1f2937; }
        .task-points { background: #dbeafe; color: #1e40af; padding: 4px 8px; border-radius: 15px; font-size: 12px; font-weight: 500; }
        .task-assignee { color: #6b7280; font-size: 14px; margin-bottom: 10px; }
        .task-actions { display: flex; gap: 10px; justify-content: flex-end; }
        .points-display { background: linear-gradient(135deg, #a855f7, #3b82f6); color: white; padding: 20px; border-radius: 10px; margin-bottom: 20px; text-align: center; }
        .points-number { font-size: 48px; font-weight: bold; }
        .rewards-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; }
        .reward-card { background: white; padding: 15px; border: 2px solid #e5e7eb; border-radius: 10px; cursor: pointer; transition: all 0.2s; text-align: center; }
        .reward-card:hover { border-color: #a855f7; }
        .reward-card.affordable { border-color: #a855f7; background: #faf5ff; }
        .reward-card.affordable:hover { background: #f3e8ff; }
        .reward-cost { background: #a855f7; color: white; padding: 4px 8px; border-radius: 15px; font-size: 12px; font-weight: 500; margin-top: 10px; display: inline-block; }
        .modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000; }
        .modal-content { background: white; padding: 30px; border-radius: 10px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto; }
        .modal-buttons { display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px; }
        .admin-panel { background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px; }
        .admin-actions { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-bottom: 20px; }
        .item-list { max-height: 300px; overflow-y: auto; }
        .item-row { display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #f9fafb; margin: 5px 0; border-radius: 5px; }
        .item-info { flex: 1; }
        .item-actions { display: flex; gap: 5px; }
        .hidden { display: none; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; font-weight: 500; }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 5px; }
        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .checkbox-group { display: flex; align-items: center; gap: 8px; }
        .avatar-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; margin-top: 8px; }
        .avatar-btn { padding: 8px; border: 2px solid #e5e7eb; border-radius: 5px; cursor: pointer; text-align: center; font-size: 20px; }
        .avatar-btn.selected { border-color: #3b82f6; background: #dbeafe; }
        .data-management { background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 15px; margin-bottom: 20px; }
        .data-info { font-size: 12px; color: #64748b; margin-top: 10px; }
        .file-input { display: none; }
        .file-label { display: inline-block; padding: 8px 12px; background: #3b82f6; color: white; border: 1px solid #2563eb; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: 500; }
        .file-label:hover { background: #e2e8f0; }
        .storage-status { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; }
        .status-indicator { width: 8px; height: 8px; border-radius: 50%; }
        .status-indicator.active { background: #10b981; }
        .status-indicator.inactive { background: #ef4444; }
        h1, h2, h3 { margin-bottom: 15px; color: #1f2937; }
        .text-center { text-align: center; }
        .text-gray { color: #6b7280; }
        .mb-4 { margin-bottom: 16px; }
        .flex { display: flex; }
        .justify-between { justify-content: space-between; }
        .items-center { align-items: center; }
        .gap-2 { gap: 8px; }
        .section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .drag-handle { color: #9ca3af; margin-right: 8px; user-select: none; font-size: 16px; cursor: grab; flex-shrink: 0; }
        .drag-handle:active { cursor: grabbing; }
        .item-row.dragging { opacity: 0.35; }
        .item-row.drag-over-top { box-shadow: inset 0 3px 0 0 #3b82f6; }
        .item-row.drag-over-bottom { box-shadow: inset 0 -3px 0 0 #3b82f6; }
        .bonus-badge { display: inline-block; background: linear-gradient(135deg, #f59e0b, #ef4444); color: white; font-size: 11px; font-weight: 600; padding: 2px 7px; border-radius: 10px; margin-left: 4px; }
        .streak-badge { display: inline-block; background: linear-gradient(135deg, #10b981, #3b82f6); color: white; font-size: 11px; font-weight: 600; padding: 2px 7px; border-radius: 10px; margin-left: 4px; }
        .bonus-config { background: #fef9e7; border: 1px solid #f39c12; border-radius: 6px; padding: 12px; margin-top: 10px; }
        .bonus-config label { font-size: 13px; color: #7d6608; }
        .bonus-config input[type="number"] { width: 70px !important; }
        .bonus-config .sub-options { margin-left: 16px; margin-top: 8px; }

        /* Toast Notification System */
        #toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .toast {
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 300px;
            max-width: 500px;
            padding: 16px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            font-size: 14px;
            font-weight: 500;
            pointer-events: auto;
            animation: slideIn 0.3s ease-out;
            backdrop-filter: blur(10px);
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast-success {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            border: 1px solid #059669;
        }

        .toast-error {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            border: 1px solid #dc2626;
        }

        .toast-warning {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            border: 1px solid #d97706;
        }

        .toast-info {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
            border: 1px solid #2563eb;
        }

        .toast-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .toast-message {
            flex: 1;
            line-height: 1.4;
        }

        .toast-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            font-size: 18px;
            font-weight: bold;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: background 0.2s;
        }

        .toast-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Reward Timer Configuration */
        .timer-config { background: #f0f9ff; border: 1px solid #3b82f6; border-radius: 6px; padding: 12px; margin-top: 10px; }
        .timer-config label { font-size: 13px; color: #1e40af; }
        .timer-config .sub-options { margin-left: 16px; margin-top: 8px; }
        .timer-slider-container { display: flex; align-items: center; gap: 10px; margin-top: 5px; }
        .timer-slider { flex: 1; }
        .timer-minutes-input { width: 70px !important; }

        /* Floating Timer Panel */
        #floating-timer-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            min-width: 320px;
            max-width: 400px;
            z-index: 9999;
            transition: transform 0.3s ease;
        }

        #floating-timer-panel.collapsed {
            transform: translateY(calc(100% - 50px));
        }

        #floating-timer-panel.dragging {
            transition: none;
            cursor: grabbing;
        }

        .timer-panel-header {
            background: linear-gradient(135deg, #a855f7, #3b82f6);
            color: white;
            padding: 12px 16px;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: grab;
            user-select: none;
        }

        .timer-panel-header:active {
            cursor: grabbing;
        }

        .timer-panel-title {
            font-weight: 600;
            font-size: 14px;
        }

        .timer-panel-controls {
            display: flex;
            gap: 8px;
        }

        .timer-panel-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: background 0.2s;
        }

        .timer-panel-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .timer-panel-body {
            max-height: 400px;
            overflow-y: auto;
            padding: 8px;
        }

        .timer-card {
            background: #f9fafb;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .timer-card:hover {
            border-color: #a855f7;
            background: #faf5ff;
        }

        .timer-card.active {
            border-color: #a855f7;
            background: #faf5ff;
        }

        .timer-card.paused {
            opacity: 0.7;
        }

        .timer-card.collapsed {
            padding: 8px 12px;
        }

        .timer-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }

        .timer-card-info {
            flex: 1;
            min-width: 0;
        }

        .timer-card-user {
            font-size: 12px;
            color: #6b7280;
            font-weight: 500;
        }

        .timer-card-reward {
            font-size: 14px;
            font-weight: 600;
            color: #1f2937;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .timer-card-time {
            font-size: 24px;
            font-weight: bold;
            color: #a855f7;
            font-variant-numeric: tabular-nums;
        }

        .timer-card-time.warning {
            color: #f59e0b;
        }

        .timer-card-time.danger {
            color: #ef4444;
        }

        .timer-card-controls {
            display: flex;
            gap: 4px;
            margin-top: 8px;
        }

        .timer-card-btn {
            flex: 1;
            padding: 6px;
            font-size: 11px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }

        /* Timer Drawer */
        #timer-drawer-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            animation: fadeIn 0.2s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        #timer-drawer {
            position: fixed;
            background: white;
            z-index: 10001;
            box-shadow: -4px 0 24px rgba(0, 0, 0, 0.2);
        }

        /* Desktop: Right-side panel */
        @media (min-width: 768px) {
            #timer-drawer {
                top: 0;
                right: 0;
                bottom: 0;
                width: 400px;
                animation: slideInRight 0.3s ease-out;
            }

            @keyframes slideInRight {
                from { transform: translateX(100%); }
                to { transform: translateX(0); }
            }
        }

        /* Mobile: Bottom sheet */
        @media (max-width: 767px) {
            #timer-drawer {
                left: 0;
                right: 0;
                bottom: 0;
                max-height: 80vh;
                border-radius: 20px 20px 0 0;
                animation: slideInUp 0.3s ease-out;
            }

            @keyframes slideInUp {
                from { transform: translateY(100%); }
                to { transform: translateY(0); }
            }

            #floating-timer-panel {
                max-width: calc(100vw - 40px);
            }
        }

        .timer-drawer-header {
            background: linear-gradient(135deg, #a855f7, #3b82f6);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .timer-drawer-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .timer-drawer-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .timer-drawer-body {
            padding: 24px;
            overflow-y: auto;
            max-height: calc(100vh - 80px);
        }

        .timer-progress-ring {
            position: relative;
            width: 200px;
            height: 200px;
            margin: 0 auto 24px;
        }

        .timer-progress-ring svg {
            transform: rotate(-90deg);
        }

        .timer-progress-ring circle {
            fill: none;
            stroke-width: 12;
        }

        .timer-progress-ring .background {
            stroke: #e5e7eb;
        }

        .timer-progress-ring .progress {
            stroke: #a855f7;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.5s ease;
        }

        .timer-progress-ring .timer-center-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .timer-center-time {
            font-size: 36px;
            font-weight: bold;
            color: #1f2937;
            font-variant-numeric: tabular-nums;
        }

        .timer-center-label {
            font-size: 12px;
            color: #6b7280;
            margin-top: 4px;
        }

        .timer-drawer-info {
            background: #f9fafb;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .timer-drawer-info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e5e7eb;
        }

        .timer-drawer-info-row:last-child {
            border-bottom: none;
        }

        .timer-drawer-info-label {
            font-size: 14px;
            color: #6b7280;
        }

        .timer-drawer-info-value {
            font-size: 14px;
            font-weight: 600;
            color: #1f2937;
        }

        .timer-drawer-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }

        .timer-drawer-actions button {
            padding: 12px;
            font-size: 14px;
            font-weight: 600;
        }

        .timer-extension-info {
            background: #fef9e7;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
            font-size: 13px;
            color: #92400e;
        }
    </style>

    <!-- Supabase JavaScript Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
    <div id="app"></div>
    <div id="toast-container"></div>

    <script>
        // Storage management functions
        const STORAGE_KEY = 'familyCleaningTracker';
        const STORAGE_VERSION = '1.0';

        // Save locking and debouncing
        let saveLock = false;
        let lastSaveTimestamp = 0;
        let autoSaveTimeout = null;
        const DEBOUNCE_INTERVAL = 1000; // Minimum 1 second between saves
        const AUTO_SAVE_DELAY = 5000; // 5 seconds after last change

        // State change detection
        let stateHash = null;
        let hasUnsavedChanges = false;

        // Security utilities for XSS prevention
        const SecurityUtils = {
            /**
             * Escapes HTML entities to prevent XSS attacks
             * @param {string} text - The text to escape
             * @returns {string} - Safely escaped text
             */
            escapeHtml(text) {
                // Handle null/undefined inputs
                if (text == null) return '';

                // Convert to string if not already
                text = String(text);

                // Use native browser API to escape HTML entities
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },

            /**
             * Sanitizes HTML by removing all tags, scripts, and event handlers
             * @param {string} html - The HTML to sanitize
             * @returns {string} - Plain text with all HTML removed
             */
            sanitizeHtml(html) {
                // Handle null/undefined inputs
                if (html == null) return '';

                // Convert to string if not already
                html = String(html);

                // Use template element to safely parse HTML without executing scripts
                // Template elements are inert - scripts don't run, images don't load
                const template = document.createElement('template');
                template.innerHTML = html;
                return template.content.textContent || '';
            },

            /**
             * Validates and sanitizes URLs to prevent javascript: and data: protocol attacks
             * @param {string} url - The URL to validate
             * @returns {string} - Sanitized URL or empty string if invalid
             */
            sanitizeUrl(url) {
                // Handle null/undefined inputs
                if (url == null) return '';

                // Convert to string and trim whitespace
                url = String(url).trim();

                // Empty string is safe
                if (url === '') return '';

                // Check for dangerous protocols
                const dangerousProtocols = /^(javascript|data|vbscript|file|about):/i;
                if (dangerousProtocols.test(url)) {
                    console.warn('SecurityUtils: Blocked dangerous URL protocol:', url);
                    return '';
                }

                // Allow relative URLs (starting with / or ./ or ../)
                if (url.startsWith('/') || url.startsWith('./') || url.startsWith('../')) {
                    return url;
                }

                // Allow fragment identifiers and query strings
                if (url.startsWith('#') || url.startsWith('?')) {
                    return url;
                }

                // Validate absolute URLs - must be http or https
                try {
                    const parsedUrl = new URL(url, window.location.href);
                    if (parsedUrl.protocol === 'http:' || parsedUrl.protocol === 'https:') {
                        return url;
                    } else {
                        console.warn('SecurityUtils: Blocked non-HTTP(S) URL:', url);
                        return '';
                    }
                } catch (e) {
                    // If URL parsing fails, be conservative and return empty string
                    console.warn('SecurityUtils: Invalid URL format:', url);
                    return '';
                }
            }
        };

        // Time utilities for manipulation-resistant timestamps
        const TimeUtils = {
            pageLoadTime: Date.now(),
            performanceStart: performance.now(),

            /**
             * Returns current timestamp using performance.now() to prevent client-side time manipulation
             * @returns {number} - Reliable timestamp in milliseconds
             */
            now() {
                return this.pageLoadTime + (performance.now() - this.performanceStart);
            },

            /**
             * Validates that a stored timestamp hasn't been manipulated via clock changes
             * @param {number} storedTime - Previously stored timestamp
             * @returns {boolean} - True if time appears valid, false if manipulation detected
             */
            validateTime(storedTime) {
                if (!storedTime || typeof storedTime !== 'number') return false;

                const now = this.now();
                const maxFutureTime = 60000; // Allow 1 minute into the future for clock skew
                const maxPastTime = 365 * 24 * 60 * 60 * 1000; // 1 year in the past

                // Check if stored time is suspiciously far in the future or past
                if (storedTime > now + maxFutureTime) {
                    console.warn('üîí Security: Detected time manipulation - timestamp in future');
                    return false;
                }

                if (storedTime < now - maxPastTime) {
                    console.warn('üîí Security: Detected time manipulation - timestamp too far in past');
                    return false;
                }

                return true;
            }
        };

        // Global security for device-wide rate limiting
        const GLOBAL_SECURITY_KEY = 'familyCleaningTracker_GlobalSecurity';
        const GlobalSecurity = {
            maxGlobalAttempts: 10,
            globalLockoutTime: 1800000, // 30 minutes in milliseconds
            failedAttempts: [],

            /**
             * Load global security data from localStorage
             */
            load() {
                try {
                    const stored = localStorage.getItem(GLOBAL_SECURITY_KEY);
                    if (stored) {
                        const data = JSON.parse(stored);
                        this.failedAttempts = data.failedAttempts || [];

                        // Clean up old attempts (older than lockout period)
                        const now = TimeUtils.now();
                        this.failedAttempts = this.failedAttempts.filter(attempt => {
                            return TimeUtils.validateTime(attempt.timestamp) &&
                                   (now - attempt.timestamp) < this.globalLockoutTime;
                        });

                        console.log('üîí Security: Loaded global security data');
                    }
                } catch (error) {
                    console.error('üîí Security: Failed to load global security data', error);
                    this.failedAttempts = [];
                }
            },

            /**
             * Save global security data to localStorage
             */
            save() {
                try {
                    const data = {
                        failedAttempts: this.failedAttempts
                    };
                    localStorage.setItem(GLOBAL_SECURITY_KEY, JSON.stringify(data));
                } catch (error) {
                    console.error('üîí Security: Failed to save global security data', error);
                }
            },

            /**
             * Check if device is globally locked out
             * @returns {Object} - { isLocked: boolean, remainingTime: number }
             */
            isGloballyLocked() {
                const now = TimeUtils.now();

                // Clean up expired attempts
                this.failedAttempts = this.failedAttempts.filter(attempt => {
                    return TimeUtils.validateTime(attempt.timestamp) &&
                           (now - attempt.timestamp) < this.globalLockoutTime;
                });

                if (this.failedAttempts.length >= this.maxGlobalAttempts) {
                    const oldestAttempt = this.failedAttempts[0];
                    const timeSinceOldest = now - oldestAttempt.timestamp;

                    if (timeSinceOldest < this.globalLockoutTime) {
                        const remainingTime = this.globalLockoutTime - timeSinceOldest;
                        console.warn('üîí Security: Device globally locked due to too many failed attempts');
                        return {
                            isLocked: true,
                            remainingTime: remainingTime
                        };
                    } else {
                        // Lockout expired, clear attempts
                        this.failedAttempts = [];
                        this.save();
                    }
                }

                return { isLocked: false, remainingTime: 0 };
            },

            /**
             * Record a failed login attempt
             * @param {number} userId - ID of user who failed login
             */
            recordFailedAttempt(userId) {
                const now = TimeUtils.now();

                this.failedAttempts.push({
                    userId: userId,
                    timestamp: now
                });

                console.warn(`üîí Security: Failed login attempt recorded (${this.failedAttempts.length}/${this.maxGlobalAttempts})`);

                this.save();
            },

            /**
             * Clear all failed attempts (called on successful login)
             */
            clearAttempts() {
                this.failedAttempts = [];
                this.save();
                console.log('üîí Security: Global failed attempts cleared');
            }
        };

        // Initialize global security on page load
        GlobalSecurity.load();

        // Input validation limits to prevent overflow and DoS attacks
        const LIMITS = {
            // Points limits
            MAX_POINTS: 999999,
            MIN_POINTS: 0,

            // String length limits
            MAX_NAME_LENGTH: 50,
            MAX_TASK_NAME_LENGTH: 100,
            MAX_PASSWORD_LENGTH: 50,
            MAX_CATEGORY_LENGTH: 30,
            MAX_REJECTION_REASON_LENGTH: 200,

            // Entity count limits
            MAX_TASKS_PER_CATEGORY: 50,
            MAX_FAMILY_MEMBERS: 20,
            MAX_REWARDS: 100,

            // Numeric value limits
            MAX_TASK_POINTS: 10000,
            MIN_TASK_POINTS: 1,
            MAX_TIME_ESTIMATE: 480, // 8 hours in minutes
            MIN_TIME_ESTIMATE: 1,
            MAX_REWARD_COST: 999999,
            MIN_REWARD_COST: 1
        };

        // Validation utilities for input constraints
        const ValidationUtils = {
            /**
             * Validates and truncates a string to maximum length
             * @param {string} value - String to validate
             * @param {number} maxLength - Maximum allowed length
             * @param {string} fieldName - Name of field for error messages
             * @returns {Object} - { valid: boolean, error: string|null, value: string }
             */
            validateString(value, maxLength, fieldName) {
                if (value == null) {
                    return { valid: true, error: null, value: '' };
                }

                const str = String(value);

                if (str.length > maxLength) {
                    const truncated = str.substring(0, maxLength);
                    console.warn(`‚ö†Ô∏è Validation: ${fieldName} truncated from ${str.length} to ${maxLength} characters`);
                    return {
                        valid: true,
                        error: `${fieldName} was truncated to ${maxLength} characters`,
                        value: truncated
                    };
                }

                return { valid: true, error: null, value: str };
            },

            /**
             * Validates and clamps a number to range
             * @param {number} value - Number to validate
             * @param {number} min - Minimum allowed value
             * @param {number} max - Maximum allowed value
             * @param {string} fieldName - Name of field for error messages
             * @returns {Object} - { valid: boolean, error: string|null, value: number }
             */
            validateNumber(value, min, max, fieldName) {
                let num = Number(value);

                if (isNaN(num)) {
                    console.warn(`‚ö†Ô∏è Validation: ${fieldName} is not a valid number, defaulting to ${min}`);
                    return {
                        valid: true,
                        error: `${fieldName} must be a number`,
                        value: min
                    };
                }

                let clamped = num;
                let wasClamped = false;

                if (num < min) {
                    clamped = min;
                    wasClamped = true;
                } else if (num > max) {
                    clamped = max;
                    wasClamped = true;
                }

                if (wasClamped) {
                    console.warn(`‚ö†Ô∏è Validation: ${fieldName} clamped from ${num} to ${clamped}`);
                    return {
                        valid: true,
                        error: `${fieldName} was adjusted to valid range (${min}-${max})`,
                        value: clamped
                    };
                }

                return { valid: true, error: null, value: clamped };
            },

            /**
             * Enforces points limits and clamps to valid range
             * @param {number} points - Points value to enforce
             * @returns {number} - Clamped points value
             */
            enforcePoints(points) {
                const result = this.validateNumber(points, LIMITS.MIN_POINTS, LIMITS.MAX_POINTS, 'Points');
                return result.value;
            },

            /**
             * Checks if adding an entity would exceed count limits
             * @param {number} currentCount - Current count of entities
             * @param {number} maxCount - Maximum allowed count
             * @param {string} entityType - Type of entity for error message
             * @returns {Object} - { allowed: boolean, error: string|null }
             */
            canAddEntity(currentCount, maxCount, entityType) {
                if (currentCount >= maxCount) {
                    console.error(`‚ö†Ô∏è Validation: Cannot add ${entityType}, limit of ${maxCount} reached`);
                    return {
                        allowed: false,
                        error: `Cannot add more ${entityType}. Maximum limit of ${maxCount} reached.`
                    };
                }
                return { allowed: true, error: null };
            },

            /**
             * Validates all fields in a member object
             * @param {Object} member - Member object to validate
             * @returns {Object} - Validated member object with warnings
             */
            validateMember(member) {
                const warnings = [];

                // Validate name
                const nameResult = this.validateString(member.name, LIMITS.MAX_NAME_LENGTH, 'Member name');
                member.name = nameResult.value;
                if (nameResult.error) warnings.push(nameResult.error);

                // Validate password
                const passwordResult = this.validateString(member.password, LIMITS.MAX_PASSWORD_LENGTH, 'Password');
                member.password = passwordResult.value;
                if (passwordResult.error) warnings.push(passwordResult.error);

                // Validate points
                const pointsResult = this.validateNumber(member.points, LIMITS.MIN_POINTS, LIMITS.MAX_POINTS, 'Member points');
                member.points = pointsResult.value;
                if (pointsResult.error) warnings.push(pointsResult.error);

                return { member, warnings };
            },

            /**
             * Validates all fields in a task object
             * @param {Object} task - Task object to validate
             * @returns {Object} - Validated task object with warnings
             */
            validateTask(task) {
                const warnings = [];

                // Validate task name
                const nameResult = this.validateString(task.name, LIMITS.MAX_TASK_NAME_LENGTH, 'Task name');
                task.name = nameResult.value;
                if (nameResult.error) warnings.push(nameResult.error);

                // Validate assignee
                const assigneeResult = this.validateString(task.assignee, LIMITS.MAX_NAME_LENGTH, 'Assignee');
                task.assignee = assigneeResult.value;
                if (assigneeResult.error) warnings.push(assigneeResult.error);

                // Validate points
                const pointsResult = this.validateNumber(task.points, LIMITS.MIN_TASK_POINTS, LIMITS.MAX_TASK_POINTS, 'Task points');
                task.points = pointsResult.value;
                if (pointsResult.error) warnings.push(pointsResult.error);

                // Validate time estimate
                const timeResult = this.validateNumber(task.timeEstimate, LIMITS.MIN_TIME_ESTIMATE, LIMITS.MAX_TIME_ESTIMATE, 'Time estimate');
                task.timeEstimate = timeResult.value;
                if (timeResult.error) warnings.push(timeResult.error);

                return { task, warnings };
            },

            /**
             * Validates all fields in a reward object
             * @param {Object} reward - Reward object to validate
             * @returns {Object} - Validated reward object with warnings
             */
            validateReward(reward) {
                const warnings = [];

                // Validate reward name
                const nameResult = this.validateString(reward.name, LIMITS.MAX_NAME_LENGTH, 'Reward name');
                reward.name = nameResult.value;
                if (nameResult.error) warnings.push(nameResult.error);

                // Validate category
                const categoryResult = this.validateString(reward.category, LIMITS.MAX_CATEGORY_LENGTH, 'Reward category');
                reward.category = categoryResult.value;
                if (categoryResult.error) warnings.push(categoryResult.error);

                // Validate cost
                const costResult = this.validateNumber(reward.cost, LIMITS.MIN_REWARD_COST, LIMITS.MAX_REWARD_COST, 'Reward cost');
                reward.cost = costResult.value;
                if (costResult.error) warnings.push(costResult.error);

                return { reward, warnings };
            }
        };

        function saveToStorageInternal() {
            try {
                const dataToSave = {
                    version: STORAGE_VERSION,
                    timestamp: new Date().toISOString(),
                    familyMembers: appState.familyMembers,
                    settings: appState.settings,
                    tasks: appState.tasks,
                    rewards: appState.rewards,
                    loginAttempts: appState.loginAttempts,
                    pendingRewards: appState.pendingRewards,
                    streaks: appState.streaks,
                    activeRewardTimers: appState.activeRewardTimers,
                    timerPanelCollapsed: appState.timerPanelCollapsed,
                    timerPanelPosition: appState.timerPanelPosition
                };

                const jsonData = JSON.stringify(dataToSave);
                const dataSize = new Blob([jsonData]).size;

                // Warn if approaching 5MB localStorage limit
                if (dataSize > 4 * 1024 * 1024) {
                    console.warn(`‚ö†Ô∏è Storage size warning: ${(dataSize / 1024 / 1024).toFixed(2)}MB (approaching 5MB limit)`);
                }

                // Attempt to save
                localStorage.setItem(STORAGE_KEY, jsonData);

                // Verify the write by reading back and comparing
                const savedData = localStorage.getItem(STORAGE_KEY);
                if (savedData !== jsonData) {
                    throw new Error('Verification failed: saved data does not match');
                }

                return {
                    success: true,
                    size: dataSize
                };

            } catch (error) {
                let errorMessage = 'Unknown storage error';
                let shouldExport = false;

                // Handle specific error types
                if (error.name === 'QuotaExceededError' || error.code === 22) {
                    errorMessage = 'Storage quota exceeded. Your data has been automatically downloaded as a backup file.';
                    console.error('‚ùå QuotaExceededError: localStorage is full');
                    shouldExport = true;
                } else if (error.name === 'SecurityError') {
                    errorMessage = 'Cannot save in private/incognito mode. Please use normal browsing mode or download your data manually.';
                    console.error('‚ùå SecurityError: localStorage unavailable (private mode or security restrictions)');
                    shouldExport = true;
                } else if (error.message && error.message.includes('Verification failed')) {
                    errorMessage = 'Data verification failed. The save may be corrupted. Emergency backup created.';
                    console.error('‚ùå Verification Error: Saved data does not match original');
                    shouldExport = true;
                } else {
                    errorMessage = `Storage error: ${error.message}`;
                    console.error('‚ùå Storage error:', error);
                    shouldExport = true;
                }

                // Trigger emergency export on failure
                if (shouldExport) {
                    emergencyExportData();
                }

                return {
                    success: false,
                    error: errorMessage
                };
            }
        }

        function saveToStorage() {
            // Check if a save is already in progress
            if (saveLock) {
                console.warn('‚ö†Ô∏è Save already in progress, skipping concurrent save attempt');
                return { success: false, error: 'Save already in progress' };
            }

            // Check debounce interval (minimum 1 second between saves)
            const now = Date.now();
            const timeSinceLastSave = now - lastSaveTimestamp;
            if (timeSinceLastSave < DEBOUNCE_INTERVAL) {
                const remainingTime = DEBOUNCE_INTERVAL - timeSinceLastSave;
                console.log(`‚è±Ô∏è Debouncing: ${remainingTime}ms remaining before next save allowed`);
                return { success: false, error: 'Debounce interval not met' };
            }

            // Acquire lock
            saveLock = true;
            console.log('üîí Save lock acquired');

            try {
                // Perform the actual save
                const result = saveToStorageInternal();

                // Update timestamp on successful save
                if (result.success) {
                    lastSaveTimestamp = Date.now();
                    console.log('‚úÖ Save completed successfully');
                }

                return result;
            } finally {
                // Always release lock
                saveLock = false;
                console.log('üîì Save lock released');
            }
        }

        function emergencyExportData() {
            try {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const dataToExport = {
                    version: STORAGE_VERSION,
                    exportedAt: new Date().toISOString(),
                    emergencyBackup: true,
                    familyMembers: appState.familyMembers,
                    settings: appState.settings,
                    tasks: appState.tasks,
                    rewards: appState.rewards,
                    pendingRewards: appState.pendingRewards,
                    streaks: appState.streaks,
                    loginAttempts: appState.loginAttempts
                };

                const dataBlob = new Blob([JSON.stringify(dataToExport, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `family-tracker-emergency-${timestamp}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                console.warn('‚ö†Ô∏è EMERGENCY BACKUP: Data automatically downloaded due to storage failure');
                return true;
            } catch (error) {
                console.error('‚ùå Emergency export failed:', error);
                return false;
            }
        }

        function loadFromStorage() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (!saved) return false;

                const data = JSON.parse(saved);

                // Validate version compatibility
                if (data.version !== STORAGE_VERSION) {
                    console.warn('Storage version mismatch. Using defaults.');
                    return false;
                }

                // Restore data
                appState.familyMembers = data.familyMembers || appState.familyMembers;

                // Migrate old data: add role field if missing
                appState.familyMembers = appState.familyMembers.map(member => {
                    if (!member.role) {
                        member.role = member.isParent ? 'parent' : 'child';
                    }
                    return member;
                });

                appState.settings = { ...appState.settings, ...data.settings };
                appState.tasks = { ...appState.tasks, ...data.tasks };
                appState.rewards = data.rewards || appState.rewards;
                appState.loginAttempts = data.loginAttempts || {};
                appState.pendingRewards = data.pendingRewards || [];
                appState.streaks = data.streaks || {};
                appState.activeRewardTimers = data.activeRewardTimers || [];
                appState.timerPanelCollapsed = data.timerPanelCollapsed || false;
                appState.timerPanelPosition = data.timerPanelPosition || { x: null, y: null };

                // Restore and adjust active timers for elapsed time
                const now = Date.now();
                appState.activeRewardTimers = appState.activeRewardTimers.filter(timer => {
                    // Migrate old timers that don't have 'started' field
                    if (timer.started === undefined) {
                        timer.started = true; // Assume old timers were already started
                    }

                    // Calculate time elapsed since last tick (if timer was running)
                    if (!timer.paused && timer.started && timer.lastTick) {
                        const elapsed = now - timer.lastTick;
                        timer.remainingMs -= elapsed;

                        // If timer expired while page was closed, remove it
                        if (timer.remainingMs <= 0) {
                            console.log(`‚è∞ Timer expired during page refresh: ${timer.rewardName} for ${timer.userName}`);
                            return false; // Remove expired timer
                        }
                    }

                    // Update lastTick to current time
                    timer.lastTick = now;
                    return true; // Keep timer
                });

                // Clean up any orphaned data from legacy imports
                StateCleanup.cleanupAll();

                return true;
            } catch (error) {
                console.error('Failed to load from localStorage:', error);
                return false;
            }
        }

        function exportData() {
            const dataToExport = {
                version: STORAGE_VERSION,
                exportedAt: new Date().toISOString(),
                familyName: prompt('Enter family name for this backup:', 'MyFamily') || 'MyFamily',
                familyMembers: appState.familyMembers,
                settings: appState.settings,
                tasks: appState.tasks,
                rewards: appState.rewards,
                pendingRewards: appState.pendingRewards,
                streaks: appState.streaks
            };

            const dataBlob = new Blob([JSON.stringify(dataToExport, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `family-cleaning-backup-${DateUtils.formatForFilename()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showToast('Data exported successfully! Check your downloads folder.', 'success');
        }

        function validateImportedData(data) {
            const errors = [];

            // Check if data exists
            if (!data || typeof data !== 'object') {
                return { valid: false, errors: ['Invalid data format: not an object'] };
            }

            // Validate version field
            if (!data.version || typeof data.version !== 'string') {
                errors.push('Missing or invalid version field');
            }

            // Validate familyMembers array
            if (!Array.isArray(data.familyMembers)) {
                errors.push('familyMembers must be an array');
            } else {
                if (data.familyMembers.length === 0) {
                    errors.push('familyMembers array is empty');
                }

                data.familyMembers.forEach((member, index) => {
                    if (!member || typeof member !== 'object') {
                        errors.push(`familyMembers[${index}]: not an object`);
                        return;
                    }

                    // Required fields
                    if (!member.id || typeof member.id !== 'number') {
                        errors.push(`familyMembers[${index}]: missing or invalid id`);
                    }
                    if (!member.name || typeof member.name !== 'string') {
                        errors.push(`familyMembers[${index}]: missing or invalid name`);
                    }
                    if (typeof member.points !== 'number') {
                        errors.push(`familyMembers[${index}]: missing or invalid points`);
                    }
                    if (typeof member.isParent !== 'boolean') {
                        errors.push(`familyMembers[${index}]: missing or invalid isParent`);
                    }
                    if (!member.avatar || typeof member.avatar !== 'string') {
                        errors.push(`familyMembers[${index}]: missing or invalid avatar`);
                    }

                    // Optional but typed fields
                    if (member.role && typeof member.role !== 'string') {
                        errors.push(`familyMembers[${index}]: invalid role type`);
                    }
                    if (member.password && typeof member.password !== 'string') {
                        errors.push(`familyMembers[${index}]: invalid password type`);
                    }
                });
            }

            // Validate tasks object
            if (!data.tasks || typeof data.tasks !== 'object' || Array.isArray(data.tasks)) {
                errors.push('tasks must be an object');
            } else {
                // Validate each task category
                const validCategories = ['daily', 'weekly', 'monthly', 'custom'];
                for (const category in data.tasks) {
                    if (!validCategories.includes(category)) {
                        continue; // Skip unknown categories but don't error
                    }

                    if (!Array.isArray(data.tasks[category])) {
                        errors.push(`tasks.${category} must be an array`);
                        continue;
                    }

                    data.tasks[category].forEach((task, index) => {
                        if (!task || typeof task !== 'object') {
                            errors.push(`tasks.${category}[${index}]: not an object`);
                            return;
                        }

                        if (!task.id || typeof task.id !== 'number') {
                            errors.push(`tasks.${category}[${index}]: missing or invalid id`);
                        }
                        if (!task.name || typeof task.name !== 'string') {
                            errors.push(`tasks.${category}[${index}]: missing or invalid name`);
                        }
                        if (typeof task.points !== 'number') {
                            errors.push(`tasks.${category}[${index}]: missing or invalid points`);
                        }
                        // Validate completions field (should be an object, not boolean)
                        if (task.completions !== undefined && (typeof task.completions !== 'object' || Array.isArray(task.completions))) {
                            errors.push(`tasks.${category}[${index}]: completions must be an object`);
                        }
                    });
                }
            }

            // Validate rewards array
            if (data.rewards !== undefined) {
                if (!Array.isArray(data.rewards)) {
                    errors.push('rewards must be an array');
                } else {
                    data.rewards.forEach((reward, index) => {
                        if (!reward || typeof reward !== 'object') {
                            errors.push(`rewards[${index}]: not an object`);
                            return;
                        }

                        if (!reward.id || typeof reward.id !== 'number') {
                            errors.push(`rewards[${index}]: missing or invalid id`);
                        }
                        if (!reward.name || typeof reward.name !== 'string') {
                            errors.push(`rewards[${index}]: missing or invalid name`);
                        }
                        if (typeof reward.cost !== 'number') {
                            errors.push(`rewards[${index}]: missing or invalid cost`);
                        }
                    });
                }
            }

            // Validate settings object
            if (data.settings !== undefined) {
                if (!data.settings || typeof data.settings !== 'object' || Array.isArray(data.settings)) {
                    errors.push('settings must be an object');
                } else {
                    if (data.settings.pointMultiplier !== undefined && typeof data.settings.pointMultiplier !== 'number') {
                        errors.push('settings.pointMultiplier must be a number');
                    }
                    if (data.settings.autoSave !== undefined && typeof data.settings.autoSave !== 'boolean') {
                        errors.push('settings.autoSave must be a boolean');
                    }
                    if (data.settings.showCompletedTasks !== undefined && typeof data.settings.showCompletedTasks !== 'boolean') {
                        errors.push('settings.showCompletedTasks must be a boolean');
                    }
                }
            }

            // Validate pendingRewards array
            if (data.pendingRewards !== undefined && !Array.isArray(data.pendingRewards)) {
                errors.push('pendingRewards must be an array');
            }

            // Validate streaks object
            if (data.streaks !== undefined) {
                if (typeof data.streaks !== 'object' || Array.isArray(data.streaks)) {
                    errors.push('streaks must be an object');
                }
            }

            return {
                valid: errors.length === 0,
                errors: errors
            };
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);

                    // Validate the imported data structure
                    const validation = validateImportedData(importedData);
                    if (!validation.valid) {
                        const errorList = validation.errors.join('\n‚Ä¢ ');
                        alert('‚ùå Invalid backup file format!\n\nValidation errors:\n‚Ä¢ ' + errorList);
                        console.error('Import validation failed:', validation.errors);
                        return;
                    }

                    // Check version compatibility
                    const versionMatch = importedData.version === STORAGE_VERSION;
                    if (!versionMatch) {
                        const proceed = confirm(
                            '‚ö†Ô∏è Version Mismatch Warning\n\n' +
                            'Import version: ' + importedData.version + '\n' +
                            'Current version: ' + STORAGE_VERSION + '\n\n' +
                            'The backup file was created with a different version.\n' +
                            'Data migration will be attempted, but some features may not work correctly.\n\n' +
                            'Do you want to continue?'
                        );
                        if (!proceed) {
                            return;
                        }
                    }

                    // Prepare import preview
                    const familyName = importedData.familyName || 'Unknown Family';
                    const exportDate = importedData.exportedAt ? DateUtils.formatDateOnly(importedData.exportedAt) : 'Unknown date';
                    const memberCount = importedData.familyMembers.length;
                    const taskCount = Object.values(importedData.tasks || {}).reduce((sum, arr) => sum + (Array.isArray(arr) ? arr.length : 0), 0);
                    const rewardCount = (importedData.rewards || []).length;

                    // Show manual backup reminder before proceeding
                    const backupReminder = confirm(
                        '‚ö†Ô∏è IMPORTANT: Manual Backup Reminder\n\n' +
                        'Before importing, have you backed up your current data?\n\n' +
                        'This import will REPLACE ALL current data:\n' +
                        '‚Ä¢ ' + memberCount + ' family members\n' +
                        '‚Ä¢ ' + taskCount + ' tasks\n' +
                        '‚Ä¢ ' + rewardCount + ' rewards\n\n' +
                        'Source: "' + familyName + '"\n' +
                        'Export date: ' + exportDate + '\n\n' +
                        'Click OK to continue with import.\n' +
                        'Click Cancel to abort and back up your data first.'
                    );

                    if (!backupReminder) {
                        return;
                    }

                    // Import the data
                    appState.familyMembers = importedData.familyMembers;

                    // Migrate old data: add role field if missing
                    appState.familyMembers = appState.familyMembers.map(member => {
                        if (!member.role) {
                            member.role = member.isParent ? 'parent' : 'child';
                        }
                        return member;
                    });

                    appState.settings = { ...appState.settings, ...importedData.settings };
                    appState.tasks = { ...appState.tasks, ...importedData.tasks };
                    appState.rewards = importedData.rewards || appState.rewards;
                    appState.pendingRewards = importedData.pendingRewards || [];
                    appState.streaks = importedData.streaks || {};
                    appState.loginAttempts = {};

                    // Reset login state
                    appState.currentUser = null;
                    appState.currentView = 'login';

                    // Save to localStorage
                    const saveResult = saveToStorage();
                    if (!saveResult.success) {
                        showToast('Warning: Import completed but save failed! ' + saveResult.error + '. Data may not persist.', 'warning', 5000);
                    } else {
                        // Update hash after successful import and save
                        stateHash = calculateStateHash();
                        hasUnsavedChanges = false;
                    }

                    showToast(`Data imported successfully! ${memberCount} members, ${taskCount} tasks, and ${rewardCount} rewards loaded. Please log in again.`, 'success', 5000);
                    safeRender();

                } catch (error) {
                    console.error('Import failed:', error);
                    if (error instanceof SyntaxError) {
                        alert('‚ùå Failed to parse backup file.\n\nThe file is not valid JSON or is corrupted.');
                    } else {
                        alert('‚ùå Failed to import data.\n\nError: ' + error.message);
                    }
                }
            };
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }

        function clearAllData() {
            if (!validateParentAccess('clear all data')) return;
            
            if (!confirm('‚ö†Ô∏è Are you sure you want to clear ALL data?\n\nThis will reset everything to defaults.\n\nThis action cannot be undone!')) {
                return;
            }
            
            // Reset to default state
            appState.familyMembers = [
                { id: 1, name: 'Parent 1', avatar: 'üë®‚Äçü¶≤', points: 0, isParent: true, role: 'parent', password: 'parent123' },
                { id: 2, name: 'Parent 2', avatar: 'üë©', points: 0, isParent: true, role: 'parent', password: 'parent456' },
                { id: 3, name: 'Teen (15)', avatar: 'üßë‚Äçüéì', points: 0, isParent: false, role: 'teen', password: 'teen123' },
                { id: 4, name: 'Child (7)', avatar: 'üßí', points: 0, isParent: false, role: 'child', password: 'child123' }
            ];
            
            // Clear all task completions
            Object.keys(appState.tasks).forEach(category => {
                appState.tasks[category].forEach(task => {
                    task.completions = {};
                });
            });
            
            appState.loginAttempts = {};
            appState.pendingRewards = [];
            appState.streaks = {};
            appState.currentUser = null;
            appState.currentView = 'login';

            // Clear localStorage
            localStorage.removeItem(STORAGE_KEY);

            showToast('All data cleared and reset to defaults!', 'success');
            safeRender();
        }

        function getStorageInfo() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (!saved) return { exists: false };
                
                const data = JSON.parse(saved);
                return {
                    exists: true,
                    timestamp: data.timestamp,
                    version: data.version,
                    size: (new Blob([saved]).size / 1024).toFixed(2) + ' KB'
                };
            } catch (error) {
                return { exists: false, error: true };
            }
        }

        // Auto-save function
        function scheduleAutoSave() {
            // Only schedule auto-save if enabled and user is logged in
            if (!appState.settings.autoSave || !appState.currentUser) {
                return;
            }

            // Clear any existing scheduled save
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
            }

            // Schedule a save for 5 seconds after the last change
            autoSaveTimeout = setTimeout(() => {
                console.log('üîÑ Auto-save triggered (5 seconds after last change)');

                // Check if there are actually unsaved changes
                if (!hasUnsavedChanges) {
                    console.log('‚è≠Ô∏è No unsaved changes flag set, skipping save');
                    autoSaveTimeout = null;
                    return;
                }

                // Calculate current state hash
                const currentHash = calculateStateHash();

                // Only save if hash has changed
                if (currentHash === stateHash) {
                    console.log('‚è≠Ô∏è State hash unchanged, skipping unnecessary save');
                    hasUnsavedChanges = false;
                    autoSaveTimeout = null;
                    return;
                }

                // State has changed, perform save
                const result = saveToStorage();
                if (!result.success && result.error !== 'Debounce interval not met' && result.error !== 'Save already in progress') {
                    console.error('Auto-save failed:', result.error);
                } else if (result.success) {
                    // Update hash and reset flag on successful save
                    stateHash = currentHash;
                    hasUnsavedChanges = false;
                    console.log('‚úÖ State hash updated after successful save');
                }
                autoSaveTimeout = null;
            }, AUTO_SAVE_DELAY);

            console.log('‚è≤Ô∏è Auto-save scheduled (5 seconds from now)');
        }

        // Calculate hash of critical application state
        function calculateStateHash() {
            // Hash familyMembers, tasks, rewards, and settings
            const criticalState = {
                familyMembers: appState.familyMembers,
                tasks: appState.tasks || [],
                rewards: appState.rewards || [],
                settings: appState.settings
            };

            // Simple hash function using JSON string
            const stateString = JSON.stringify(criticalState);
            let hash = 0;
            for (let i = 0; i < stateString.length; i++) {
                const char = stateString.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return hash;
        }

        // Mark state as changed and schedule auto-save
        function markStateChanged() {
            hasUnsavedChanges = true;
            scheduleAutoSave();
        }

        // Legacy function for backward compatibility - now triggers event-driven save
        function autoSave() {
            markStateChanged();
        }

        // ===== TOAST NOTIFICATION SYSTEM =====
        const ToastManager = {
            toasts: [],
            maxToasts: 3,
            nextId: 1,

            show(message, type = 'info', duration = 3000) {
                // Create new toast
                const toast = {
                    id: this.nextId++,
                    message: SecurityUtils.escapeHtml(message),
                    type: type, // success, error, warning, info
                    duration: duration
                };

                // Add to toasts array
                this.toasts.push(toast);

                // If we exceed max toasts, remove the oldest
                if (this.toasts.length > this.maxToasts) {
                    this.toasts.shift();
                }

                // Auto-dismiss after duration
                if (duration > 0) {
                    setTimeout(() => {
                        this.remove(toast.id);
                    }, duration);
                }

                // Render toasts
                this.render();
            },

            remove(id) {
                this.toasts = this.toasts.filter(t => t.id !== id);
                this.render();
            },

            render() {
                const container = document.getElementById('toast-container');
                if (!container) return;

                container.innerHTML = this.toasts.map(toast => {
                    const icons = {
                        success: '‚úÖ',
                        error: '‚ùå',
                        warning: '‚ö†Ô∏è',
                        info: '‚ÑπÔ∏è'
                    };

                    return `
                        <div class="toast toast-${toast.type}" data-toast-id="${toast.id}">
                            <span class="toast-icon">${icons[toast.type] || icons.info}</span>
                            <span class="toast-message">${toast.message}</span>
                            <button class="toast-close" onclick="ToastManager.remove(${toast.id})">‚úï</button>
                        </div>
                    `;
                }).join('');
            }
        };

        // Wrapper function for easy access
        function showToast(message, type = 'info', duration = 3000) {
            ToastManager.show(message, type, duration);
        }

        // ===== SECURITY VALIDATION =====
        function validateParentAccess(actionName) {
            if (!appState.currentUser) {
                showToast('Please log in first', 'warning');
                return false;
            }
            if (!appState.currentUser.isParent) {
                showToast('Admin access required! Only parents can ' + actionName + '.', 'warning');
                console.warn('SECURITY: Unauthorized access attempt by:', appState.currentUser.name);
                return false;
            }
            return true;
        }

        // App state
        let appState = {
            currentView: 'login',
            currentUser: null,
            loginAttempts: {},
            selectedUserId: null,
            userPassword: '',
            showPassword: false,
            showMemberPasswords: {},
            editingTask: null,
            editingReward: null,
            editingMember: null,
            confirmDialog: null,
            pendingRewards: [],
            familyMembers: [
                { id: 1, name: 'Parent 1', avatar: 'üë®‚Äçü¶≤', points: 0, isParent: true, role: 'parent', password: 'parent123' },
                { id: 2, name: 'Parent 2', avatar: 'üë©', points: 0, isParent: true, role: 'parent', password: 'parent456' },
                { id: 3, name: 'Teen (15)', avatar: 'üßë‚Äçüéì', points: 45, isParent: false, role: 'teen', password: 'teen123' },
                { id: 4, name: 'Child (7)', avatar: 'üßí', points: 38, isParent: false, role: 'child', password: 'child123' }
            ],
            settings: {
                pointMultiplier: 1.0,
                maxLoginAttempts: 3,
                lockoutTime: 300000, // 5 minutes in milliseconds
                autoSave: true
            },
            tasks: {
                daily: [
                    { id: 1, name: 'Make beds', assignee: 'Everyone', points: 2, timeEstimate: 5, completions: {}, category: 'daily', requiresEveryone: true },
                    { id: 2, name: 'Put dirty clothes in laundry basket', assignee: 'Everyone', points: 1, timeEstimate: 2, completions: {}, category: 'daily', requiresEveryone: true },
                    { id: 3, name: 'Clear and wipe kitchen table', assignee: 'Everyone', points: 2, timeEstimate: 5, completions: {}, category: 'daily', requiresEveryone: false },
                    { id: 4, name: 'Wash dishes or load dishwasher', assignee: 'Teen (15)', points: 5, timeEstimate: 15, completions: {}, category: 'daily', requiresEveryone: false },
                    { id: 5, name: 'Unload dishwasher', assignee: 'Child (7)', points: 4, timeEstimate: 10, completions: {}, category: 'daily', requiresEveryone: false },
                    { id: 6, name: 'Wipe kitchen counters and stove', assignee: 'Teen (15)', points: 3, timeEstimate: 8, completions: {}, category: 'daily', requiresEveryone: false },
                    { id: 7, name: 'Quick bathroom check', assignee: 'Parent', points: 3, timeEstimate: 5, completions: {}, category: 'daily', requiresEveryone: false },
                    { id: 8, name: '10-minute evening tidy-up', assignee: 'Everyone', points: 3, timeEstimate: 10, completions: {}, category: 'daily', requiresEveryone: true }
                ],
                weekly: [
                    { id: 9, name: 'Monday: Vacuum/sweep living areas', assignee: 'Parent + Kids', points: 8, timeEstimate: 20, completions: {}, category: 'weekly', requiresEveryone: false },
                    { id: 10, name: 'Tuesday: Clean bathroom', assignee: 'Parent + Teen', points: 10, timeEstimate: 25, completions: {}, category: 'weekly', requiresEveryone: false },
                    { id: 11, name: 'Wednesday: Change bed linens', assignee: 'Everyone', points: 6, timeEstimate: 15, completions: {}, category: 'weekly', requiresEveryone: true },
                    { id: 12, name: 'Thursday: Dust surfaces', assignee: 'Child + Parent', points: 5, timeEstimate: 15, completions: {}, category: 'weekly', requiresEveryone: false },
                    { id: 13, name: 'Friday: Clean fridge', assignee: 'Parent + Teen', points: 8, timeEstimate: 20, completions: {}, category: 'weekly', requiresEveryone: false },
                    { id: 14, name: 'Saturday: Laundry day', assignee: 'Everyone', points: 10, timeEstimate: 30, completions: {}, category: 'weekly', requiresEveryone: false },
                    { id: 15, name: 'Sunday: Declutter one area', assignee: 'Everyone', points: 7, timeEstimate: 20, completions: {}, category: 'weekly', requiresEveryone: false }
                ],
                monthly: [
                    { id: 16, name: 'Clean windows and mirrors', assignee: 'Parent + Teen', points: 15, timeEstimate: 45, completions: {}, category: 'monthly', requiresEveryone: false },
                    { id: 17, name: 'Wipe baseboards', assignee: 'Parent + Child', points: 12, timeEstimate: 30, completions: {}, category: 'monthly', requiresEveryone: false },
                    { id: 18, name: 'Vacuum under furniture', assignee: 'Parent + Teen', points: 18, timeEstimate: 40, completions: {}, category: 'monthly', requiresEveryone: false },
                    { id: 19, name: 'Organize closet', assignee: 'Everyone', points: 20, timeEstimate: 60, completions: {}, category: 'monthly', requiresEveryone: true },
                    { id: 20, name: 'Deep clean bathroom', assignee: 'Parent + Teen', points: 25, timeEstimate: 90, completions: {}, category: 'monthly', requiresEveryone: false }
                ]
            },
            rewards: [
                { id: 1, name: '30 min extra screen time', cost: 15, category: 'Screen Time', useTimer: true, timerMinutes: 30, extensionMinutes: 10, extensionCost: 5, playSoundOnFinish: true },
                { id: 2, name: 'Choose dinner for family', cost: 25, category: 'Special Privilege', useTimer: false },
                { id: 3, name: 'Movie night pick', cost: 30, category: 'Entertainment', useTimer: false },
                { id: 4, name: 'Special treat from store', cost: 40, category: 'Treats', useTimer: false },
                { id: 5, name: 'Friend sleepover', cost: 60, category: 'Social', useTimer: false },
                { id: 6, name: 'Skip one chore day', cost: 35, category: 'Break', useTimer: false }
            ],
            timers: {},
            streaks: {},   // { [taskId]: { [userId]: { count, lastApprovedDate, currentMultiplier } } }
            activeRewardTimers: [],  // Array of active reward timers
            timerDrawer: null,  // Currently opened timer in drawer (id or null)
            timerPanelCollapsed: false,  // Whether the floating panel is collapsed
            timerPanelPosition: { x: null, y: null }  // Draggable position (desktop only)
        };

        // ===== ERROR TRACKING =====
        let lastRenderError = null;
        let renderErrorCount = 0;
        const MAX_RENDER_ERRORS = 3;

        // ===== STATE CLEANUP UTILITY =====
        const StateCleanup = {
            /**
             * Removes all orphaned data for deleted members
             * Cleans: showMemberPasswords, loginAttempts, task completions, pending rewards, streaks, timers
             */
            cleanupDeletedMembers() {
                // Get valid member IDs
                const validIds = new Set(appState.familyMembers.map(m => m.id));
                let cleanupCount = 0;

                // Clean showMemberPasswords
                for (const memberId in appState.showMemberPasswords) {
                    if (!validIds.has(parseInt(memberId))) {
                        delete appState.showMemberPasswords[memberId];
                        cleanupCount++;
                        console.log(`üßπ Cleaned showMemberPasswords for deleted member ${memberId}`);
                    }
                }

                // Clean loginAttempts
                for (const memberId in appState.loginAttempts) {
                    if (!validIds.has(parseInt(memberId))) {
                        delete appState.loginAttempts[memberId];
                        cleanupCount++;
                        console.log(`üßπ Cleaned loginAttempts for deleted member ${memberId}`);
                    }
                }

                // Clean timers
                for (const userId in appState.timers) {
                    if (!validIds.has(parseInt(userId))) {
                        delete appState.timers[userId];
                        cleanupCount++;
                        console.log(`üßπ Cleaned timers for deleted member ${userId}`);
                    }
                }

                // Clean task completions
                ['daily', 'weekly', 'monthly'].forEach(category => {
                    appState.tasks[category].forEach(task => {
                        if (task.completions) {
                            for (const userId in task.completions) {
                                if (!validIds.has(parseInt(userId))) {
                                    delete task.completions[userId];
                                    cleanupCount++;
                                    console.log(`üßπ Cleaned completion for deleted member ${userId} on task ${task.id}`);
                                }
                            }
                        }
                    });
                });

                // Clean streaks
                for (const taskId in appState.streaks) {
                    for (const userId in appState.streaks[taskId]) {
                        if (!validIds.has(parseInt(userId))) {
                            delete appState.streaks[taskId][userId];
                            cleanupCount++;
                            console.log(`üßπ Cleaned streak for deleted member ${userId} on task ${taskId}`);
                        }
                    }
                    // Remove empty task entries
                    if (Object.keys(appState.streaks[taskId]).length === 0) {
                        delete appState.streaks[taskId];
                    }
                }

                // Clean pending rewards
                const originalLength = appState.pendingRewards.length;
                appState.pendingRewards = appState.pendingRewards.filter(reward =>
                    validIds.has(reward.userId)
                );
                if (appState.pendingRewards.length < originalLength) {
                    const removed = originalLength - appState.pendingRewards.length;
                    cleanupCount += removed;
                    console.log(`üßπ Cleaned ${removed} pending rewards for deleted members`);
                }

                if (cleanupCount > 0) {
                    console.log(`‚úÖ StateCleanup: Removed ${cleanupCount} orphaned data entries for deleted members`);
                }

                return cleanupCount;
            },

            /**
             * Removes pending reward requests for a deleted reward
             * @param {number} rewardId - The ID of the deleted reward
             */
            cleanupDeletedRewards(rewardId) {
                const originalLength = appState.pendingRewards.length;
                appState.pendingRewards = appState.pendingRewards.filter(pr => pr.rewardId !== rewardId);

                const removed = originalLength - appState.pendingRewards.length;
                if (removed > 0) {
                    console.log(`üßπ StateCleanup: Removed ${removed} pending requests for deleted reward ${rewardId}`);
                }

                return removed;
            },

            /**
             * Removes streak data for a deleted task
             * @param {string} category - Task category (daily, weekly, monthly)
             * @param {number} taskId - The ID of the deleted task
             */
            cleanupDeletedTasks(category, taskId) {
                let cleanupCount = 0;

                // Clean streaks for this task
                if (appState.streaks[taskId]) {
                    delete appState.streaks[taskId];
                    cleanupCount++;
                    console.log(`üßπ StateCleanup: Removed streak data for deleted task ${taskId}`);
                }

                if (cleanupCount > 0) {
                    console.log(`‚úÖ StateCleanup: Removed ${cleanupCount} orphaned data entries for deleted task`);
                }

                return cleanupCount;
            },

            /**
             * Cleans up all orphaned data (for legacy data imports)
             * Validates and removes orphaned references for members, rewards, and tasks
             */
            cleanupAll() {
                console.log('üßπ Running full state cleanup...');
                let totalCleaned = 0;

                // Clean deleted members
                totalCleaned += this.cleanupDeletedMembers();

                // Clean deleted rewards
                const validRewardIds = new Set(appState.rewards.map(r => r.id));
                const originalPending = appState.pendingRewards.length;
                appState.pendingRewards = appState.pendingRewards.filter(pr =>
                    validRewardIds.has(pr.rewardId)
                );
                const removedRewards = originalPending - appState.pendingRewards.length;
                if (removedRewards > 0) {
                    totalCleaned += removedRewards;
                    console.log(`üßπ Cleaned ${removedRewards} pending requests for deleted rewards`);
                }

                // Clean deleted tasks
                const validTaskIds = new Set();
                ['daily', 'weekly', 'monthly'].forEach(category => {
                    appState.tasks[category].forEach(task => validTaskIds.add(task.id));
                });

                for (const taskId in appState.streaks) {
                    if (!validTaskIds.has(parseInt(taskId))) {
                        delete appState.streaks[taskId];
                        totalCleaned++;
                        console.log(`üßπ Cleaned streak for deleted task ${taskId}`);
                    }
                }

                if (totalCleaned > 0) {
                    console.log(`‚úÖ Full cleanup complete: Removed ${totalCleaned} total orphaned entries`);
                } else {
                    console.log('‚úÖ No orphaned data found');
                }

                return totalCleaned;
            }
        };

        // ===== DATE UTILITIES =====
        const DateUtils = {
            /**
             * Formats a date for user display in local timezone
             * @param {string|Date} dateInput - ISO string or Date object
             * @returns {string} Formatted as "MM/DD/YYYY, HH:MM AM/PM"
             */
            formatForDisplay(dateInput) {
                if (!dateInput) return 'N/A';

                try {
                    const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
                    if (isNaN(date.getTime())) return 'Invalid Date';

                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    const year = date.getFullYear();

                    let hours = date.getHours();
                    const minutes = String(date.getMinutes()).padStart(2, '0');
                    const ampm = hours >= 12 ? 'PM' : 'AM';
                    hours = hours % 12 || 12;

                    return `${month}/${day}/${year}, ${hours}:${minutes} ${ampm}`;
                } catch (error) {
                    console.error('Error formatting date for display:', error);
                    return 'Invalid Date';
                }
            },

            /**
             * Returns current date/time in ISO format for consistent storage
             * @returns {string} ISO 8601 formatted string
             */
            formatForStorage() {
                return new Date().toISOString();
            },

            /**
             * Formats a date as relative time ("2 hours ago", "3 days ago")
             * @param {string|Date} dateInput - ISO string or Date object
             * @returns {string} Relative time string
             */
            formatRelative(dateInput) {
                if (!dateInput) return 'N/A';

                try {
                    const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
                    if (isNaN(date.getTime())) return 'Invalid Date';

                    const now = new Date();
                    const diffMs = now - date;
                    const diffSec = Math.floor(diffMs / 1000);
                    const diffMin = Math.floor(diffSec / 60);
                    const diffHour = Math.floor(diffMin / 60);
                    const diffDay = Math.floor(diffHour / 24);
                    const diffWeek = Math.floor(diffDay / 7);
                    const diffMonth = Math.floor(diffDay / 30);
                    const diffYear = Math.floor(diffDay / 365);

                    if (diffSec < 60) {
                        return diffSec === 1 ? '1 second ago' : `${diffSec} seconds ago`;
                    } else if (diffMin < 60) {
                        return diffMin === 1 ? '1 minute ago' : `${diffMin} minutes ago`;
                    } else if (diffHour < 24) {
                        return diffHour === 1 ? '1 hour ago' : `${diffHour} hours ago`;
                    } else if (diffDay < 7) {
                        return diffDay === 1 ? '1 day ago' : `${diffDay} days ago`;
                    } else if (diffWeek < 4) {
                        return diffWeek === 1 ? '1 week ago' : `${diffWeek} weeks ago`;
                    } else if (diffMonth < 12) {
                        return diffMonth === 1 ? '1 month ago' : `${diffMonth} months ago`;
                    } else {
                        return diffYear === 1 ? '1 year ago' : `${diffYear} years ago`;
                    }
                } catch (error) {
                    console.error('Error formatting relative date:', error);
                    return 'Invalid Date';
                }
            },

            /**
             * Formats a date as date only (no time)
             * @param {string|Date} dateInput - ISO string or Date object
             * @returns {string} Formatted as "MM/DD/YYYY"
             */
            formatDateOnly(dateInput) {
                if (!dateInput) return 'N/A';

                try {
                    const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
                    if (isNaN(date.getTime())) return 'Invalid Date';

                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    const year = date.getFullYear();

                    return `${month}/${day}/${year}`;
                } catch (error) {
                    console.error('Error formatting date only:', error);
                    return 'Invalid Date';
                }
            },

            /**
             * Formats a date for filename usage (YYYY-MM-DD)
             * @param {Date} date - Date object (defaults to now)
             * @returns {string} Formatted as "YYYY-MM-DD"
             */
            formatForFilename(date = new Date()) {
                try {
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    return `${year}-${month}-${day}`;
                } catch (error) {
                    console.error('Error formatting date for filename:', error);
                    return 'unknown-date';
                }
            }
        };

        // Helper functions
        function isTaskAssignedToUser(task, user) {
            if (!user) return false;

            const assignee = task.assignee;
            const userRole = user.role || (user.isParent ? 'parent' : 'child');

            // Everyone - assigns to all users
            if (assignee === 'Everyone') return true;

            // Kids - assigns to Teen + Child roles
            if (assignee === 'Kids') {
                return userRole === 'teen' || userRole === 'child';
            }

            // Parents - assigns to Parent role only
            if (assignee === 'Parents' || assignee === 'Parent') {
                return userRole === 'parent';
            }

            // Parents + Teens - assigns to Parent + Teen roles
            if (assignee === 'Parents + Teens' || assignee === 'Parent + Teen') {
                return userRole === 'parent' || userRole === 'teen';
            }

            // Parents + Children - assigns to Parent + Child roles
            if (assignee === 'Parents + Children' || assignee === 'Parent + Child' || assignee === 'Child + Parent') {
                return userRole === 'parent' || userRole === 'child';
            }

            // Legacy: Parent + Kids - treat as Everyone
            if (assignee === 'Parent + Kids') {
                return true;
            }

            // Specific user - check by name
            if (assignee === user.name) return true;

            return false;
        }

        function isTaskCompletedByUser(task, userId) {
            return task.completions && task.completions[userId];
        }

        function getCurrentUser() {
            if (!appState.currentUser) return null;

            // Always fetch fresh copy from familyMembers array
            const freshUser = appState.familyMembers.find(m => m.id === appState.currentUser.id);

            if (!freshUser) {
                // User deleted - force logout with message
                alert('‚ö†Ô∏è Your account has been deleted. You will be logged out.');
                handleLogout();
                return null;
            }

            // Update appState with fresh reference to prevent stale data
            appState.currentUser = freshUser;
            return freshUser;
        }

        // ===== SESSION VALIDATION =====
        function validateSession() {
            // If not logged in, session is valid (will show login screen)
            if (!appState.currentUser) return true;

            // Check if current user still exists in familyMembers
            const userExists = appState.familyMembers.find(m => m.id === appState.currentUser.id);

            if (!userExists) {
                // User was deleted - force logout
                alert('‚ö†Ô∏è Your account has been deleted. You will be logged out.');
                handleLogout();
                return false;
            }

            return true;
        }

        // Wrapper to ensure current user exists before executing function
        function requireCurrentUser(fn, actionName) {
            return function(...args) {
                const user = getCurrentUser();
                if (!user) {
                    console.warn(`Action "${actionName}" requires a valid user session`);
                    return null;
                }
                return fn.apply(this, args);
            };
        }

        // ===== CONSECUTIVE COMPLETION BONUS HELPERS =====
        function getDayKey(date) {
            var d = (date instanceof Date) ? date : new Date(date);
            return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');
        }

        function getWeekKey(date) {
            var d = new Date(date instanceof Date ? date.getTime() : date);
            var day = d.getDay();                          // 0 = Sun ‚Ä¶ 6 = Sat
            d.setDate(d.getDate() - day + (day === 0 ? -6 : 1));  // rewind to Monday
            return getDayKey(d);
        }

        // Returns { count, lastApprovedDate, currentMultiplier } for a task+user, or null
        function getStreakInfo(taskId, userId) {
            return (appState.streaks[taskId] && appState.streaks[taskId][userId]) || null;
        }

        // Returns { multiplier, prospectiveCount } ‚Äî what the NEXT approval would commit
        function calculateBonusMultiplier(task, userId) {
            if (!task.bonusEnabled || task.category === 'monthly') {
                return { multiplier: 1.0, prospectiveCount: 0 };
            }

            var streak = getStreakInfo(task.id, userId);
            var currentCount = streak ? streak.count : 0;
            var lastDate = streak ? streak.lastApprovedDate : null;
            var today = new Date();

            if (lastDate) {
                if (task.category === 'daily') {
                    var todayKey = getDayKey(today);
                    if (lastDate === todayKey) {
                        // Already approved today ‚Äî no new streak increment (shouldn't normally happen)
                        return { multiplier: streak.currentMultiplier || 1.0, prospectiveCount: currentCount };
                    }
                    // Check continuity: yesterday or today
                    var yesterday = new Date(today);
                    yesterday.setDate(yesterday.getDate() - 1);
                    if (lastDate !== getDayKey(yesterday)) {
                        currentCount = 0;   // gap detected ‚Äî reset
                    }
                } else if (task.category === 'weekly') {
                    var thisWeek = getWeekKey(today);
                    if (lastDate === thisWeek) {
                        // Already approved this week
                        return { multiplier: streak.currentMultiplier || 1.0, prospectiveCount: currentCount };
                    }
                    // Check continuity: last week
                    var lastWeekDate = new Date(today);
                    lastWeekDate.setDate(lastWeekDate.getDate() - 7);
                    if (lastDate !== getWeekKey(lastWeekDate)) {
                        currentCount = 0;   // gap detected ‚Äî reset
                    }
                }
            }

            var prospectiveCount = currentCount + 1;

            // Calculate multiplier
            var base = task.bonusBaseMultiplier || 1.5;
            var multiplier;
            if (task.bonusEscalating) {
                var maxEsc = task.bonusMaxEscalations || 3;
                var step = base - 1.0;
                var escalations = Math.min(prospectiveCount - 1, maxEsc);
                multiplier = 1.0 + step + escalations * step;   // base + escalations * step
            } else {
                multiplier = base;
            }

            return { multiplier: Math.round(multiplier * 100) / 100, prospectiveCount: prospectiveCount };
        }
        // ===== END BONUS HELPERS =====

        // ===== DRAG-AND-DROP REORDERING (admin only) =====
        let dragState = null;

        function initDragAndDrop() {
            const app = document.getElementById('app');

            app.addEventListener('dragstart', function(e) {
                const row = e.target.closest('[data-drag-type]');
                if (!row) { e.preventDefault(); return; }
                dragState = {
                    type: row.dataset.dragType,
                    category: row.dataset.dragCategory || null,
                    index: parseInt(row.dataset.dragIndex)
                };
                row.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });

            app.addEventListener('dragover', function(e) {
                const row = e.target.closest('[data-drag-type]');
                if (!row || !dragState) return;
                if (row.dataset.dragType !== dragState.type) return;
                if (dragState.category && row.dataset.dragCategory !== dragState.category) return;
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                clearDropIndicators();
                var rect = row.getBoundingClientRect();
                row.classList.add(e.clientY < rect.top + rect.height / 2 ? 'drag-over-top' : 'drag-over-bottom');
            });

            app.addEventListener('dragleave', function(e) {
                var row = e.target.closest('[data-drag-type]');
                if (row && !row.contains(e.relatedTarget)) {
                    row.classList.remove('drag-over-top', 'drag-over-bottom');
                }
            });

            app.addEventListener('drop', function(e) {
                var row = e.target.closest('[data-drag-type]');
                if (!row || !dragState) return;
                if (row.dataset.dragType !== dragState.type) return;
                if (dragState.category && row.dataset.dragCategory !== dragState.category) return;
                e.preventDefault();

                var targetIndex = parseInt(row.dataset.dragIndex);
                var sourceIndex = dragState.index;
                if (sourceIndex === targetIndex) { cleanupDrag(); return; }

                var rect = row.getBoundingClientRect();
                var insertAt = e.clientY < rect.top + rect.height / 2 ? targetIndex : targetIndex + 1;

                var arr;
                if (dragState.type === 'task')   arr = appState.tasks[dragState.category];
                else if (dragState.type === 'member') arr = appState.familyMembers;
                else if (dragState.type === 'reward') arr = appState.rewards;

                if (arr) {
                    var item = arr.splice(sourceIndex, 1)[0];
                    if (sourceIndex < insertAt) insertAt--;
                    arr.splice(insertAt, 0, item);
                    autoSave();
                }
                cleanupDrag();
                safeRender();
            });

            app.addEventListener('dragend', function() { cleanupDrag(); });
        }

        function clearDropIndicators() {
            document.querySelectorAll('.drag-over-top, .drag-over-bottom').forEach(function(el) {
                el.classList.remove('drag-over-top', 'drag-over-bottom');
            });
        }

        function cleanupDrag() {
            document.querySelectorAll('.dragging').forEach(function(el) { el.classList.remove('dragging'); });
            clearDropIndicators();
            dragState = null;
        }
        // ===== END DRAG-AND-DROP =====

        // Login functions
        function selectUser(memberId) {
            appState.selectedUserId = memberId;
            appState.userPassword = '';
            safeRender();
        }

        function attemptLogin() {
            if (!appState.selectedUserId) {
                showToast('Please select a user first', 'warning');
                return;
            }

            const member = appState.familyMembers.find(m => m.id === appState.selectedUserId);
            if (!member) return;

            // Use manipulation-resistant timestamp
            const now = TimeUtils.now();

            // Check for global lockout first
            const globalLockout = GlobalSecurity.isGloballyLocked();
            if (globalLockout.isLocked) {
                const remainingTime = Math.ceil(globalLockout.remainingTime / 60000);
                alert(`‚ö†Ô∏è Security Alert: Too many failed login attempts from this device.\n\nDevice locked for ${remainingTime} more minutes.`);
                console.error('üîí Security: Login blocked due to global lockout');
                return;
            }

            // Check if specific user is locked out
            let attempts = appState.loginAttempts[appState.selectedUserId] || { count: 0, lastAttempt: 0 };

            // Validate stored timestamp to detect time manipulation
            if (attempts.lastAttempt && !TimeUtils.validateTime(attempts.lastAttempt)) {
                console.error('üîí Security: Time manipulation detected! Resetting lockout to maximum.');
                // If time manipulation detected, enforce maximum lockout
                attempts = {
                    count: appState.settings.maxLoginAttempts,
                    lastAttempt: now
                };
                appState.loginAttempts[appState.selectedUserId] = attempts;
                autoSave();
            }

            if (attempts.count >= appState.settings.maxLoginAttempts) {
                const timeSinceLastAttempt = now - attempts.lastAttempt;
                if (timeSinceLastAttempt < appState.settings.lockoutTime) {
                    const remainingTime = Math.ceil((appState.settings.lockoutTime - timeSinceLastAttempt) / 60000);
                    alert(`Account locked. Try again in ${remainingTime} minutes.`);
                    console.warn(`üîí Security: User ${member.name} locked out (${remainingTime} min remaining)`);
                    return;
                } else {
                    // Reset attempts after lockout period
                    console.log(`üîí Security: Lockout expired for user ${member.name}`);
                    appState.loginAttempts[appState.selectedUserId] = { count: 0, lastAttempt: 0 };
                    // Update attempts variable to reflect the reset
                    attempts = appState.loginAttempts[appState.selectedUserId];
                }
            }

            // Verify password
            if (appState.userPassword === member.password) {
                // Successful login
                console.log(`‚úÖ Security: Successful login for user ${member.name}`);
                appState.currentUser = member;
                appState.currentView = member.isParent ? 'admin' : 'dashboard';
                appState.selectedUserId = null;
                appState.userPassword = '';
                appState.loginAttempts[member.id] = { count: 0, lastAttempt: 0 };

                // Clear global security attempts on successful login
                GlobalSecurity.clearAttempts();

                autoSave();
                safeRender();
            } else {
                // Failed login
                console.warn(`üîí Security: Failed login attempt for user ${member.name}`);

                // Record in per-user attempts
                appState.loginAttempts[appState.selectedUserId] = {
                    count: attempts.count + 1,
                    lastAttempt: now
                };

                // Record in global security
                GlobalSecurity.recordFailedAttempt(appState.selectedUserId);

                const remainingAttempts = appState.settings.maxLoginAttempts - appState.loginAttempts[appState.selectedUserId].count;
                if (remainingAttempts > 0) {
                    showToast(`Incorrect password! ${remainingAttempts} attempts remaining.`, 'error');
                } else {
                    showToast('Too many failed attempts! Account locked for 5 minutes.', 'error', 5000);
                    console.error(`üîí Security: User ${member.name} locked out after ${appState.settings.maxLoginAttempts} failed attempts`);
                }
                appState.userPassword = '';
                autoSave();
                safeRender();
            }
        }

        function handleLogout() {
            appState.currentUser = null;
            appState.currentView = 'login';
            appState.selectedUserId = null;
            appState.userPassword = '';
            safeRender();
        }

        function switchToUser() {
            if (!appState.currentUser || !appState.currentUser.isParent) {
                showToast('Only parents can switch to user view', 'warning');
                return;
            }
            appState.currentView = 'dashboard';
            safeRender();
        }

        function switchToAdmin() {
            if (!appState.currentUser || !appState.currentUser.isParent) {
                showToast('Only parents can access admin panel', 'warning');
                return;
            }
            appState.currentView = 'admin';
            safeRender();
        }

        // Task functions
        function completeTask(taskId, category) {
            if (!appState.currentUser) return;

            const task = appState.tasks[category].find(t => t.id === taskId);
            if (!task) return;

            // Check if task is already completed by this user
            if (task.completions[appState.currentUser.id]) {
                showToast('You have already completed this task!', 'warning');
                return;
            }

            let pointsEarned = Math.round(task.points * appState.settings.pointMultiplier);

            // For children: calculate bonus and mark as pending verification
            var bonusMultiplier = 1.0;
            var prospectiveStreakCount = 0;
            if (!appState.currentUser.isParent && task.bonusEnabled && task.category !== 'monthly') {
                var bonusInfo = calculateBonusMultiplier(task, appState.currentUser.id);
                bonusMultiplier = bonusInfo.multiplier;
                prospectiveStreakCount = bonusInfo.prospectiveCount;
                pointsEarned = Math.round(task.points * appState.settings.pointMultiplier * bonusMultiplier);
            }

            if (!appState.currentUser.isParent) {
                task.completions[appState.currentUser.id] = {
                    userId: appState.currentUser.id,
                    name: appState.currentUser.name,
                    pointsEarned,
                    completedAt: new Date().toISOString(),
                    status: 'pending', // pending, approved, rejected
                    submittedAt: new Date().toISOString(),
                    bonusMultiplier: bonusMultiplier,
                    prospectiveStreakCount: prospectiveStreakCount
                };
                var bonusMsg = bonusMultiplier > 1.0 ? ' (includes ' + bonusMultiplier + 'x streak bonus!)' : '';
                showToast('Task submitted for parent approval!' + bonusMsg, 'success');
            } else {
                // Parents can complete immediately
                const memberIndex = appState.familyMembers.findIndex(m => m.id === appState.currentUser.id);
                if (memberIndex !== -1) {
                    appState.familyMembers[memberIndex].points += pointsEarned;
                }
                
                task.completions[appState.currentUser.id] = {
                    userId: appState.currentUser.id,
                    name: appState.currentUser.name,
                    pointsEarned,
                    completedAt: new Date().toISOString(),
                    status: 'approved'
                };
            }

            autoSave();
            safeRender();
        }

        function approveTask(taskId, category, userId) {
            const task = appState.tasks[category].find(t => t.id === taskId);
            if (!task || !task.completions[userId]) return;

            const completion = task.completions[userId];
            completion.status = 'approved';
            completion.approvedAt = new Date().toISOString();
            completion.approvedBy = appState.currentUser.name;

            // Award points to the user with overflow protection
            const memberIndex = appState.familyMembers.findIndex(m => m.id === userId);
            if (memberIndex !== -1) {
                const newPoints = appState.familyMembers[memberIndex].points + completion.pointsEarned;
                appState.familyMembers[memberIndex].points = ValidationUtils.enforcePoints(newPoints);
            }

            // Commit streak on approval if bonus was applied
            if (task.bonusEnabled && completion.prospectiveStreakCount) {
                if (!appState.streaks[task.id]) appState.streaks[task.id] = {};
                appState.streaks[task.id][userId] = {
                    count: completion.prospectiveStreakCount,
                    lastApprovedDate: task.category === 'weekly' ? getWeekKey(new Date()) : getDayKey(new Date()),
                    currentMultiplier: completion.bonusMultiplier || 1.0
                };
            }

            var bonusNote = (completion.bonusMultiplier && completion.bonusMultiplier > 1.0) ? ` (${completion.bonusMultiplier}x streak bonus)` : '';
            showToast(`Task approved! ${SecurityUtils.escapeHtml(completion.name)} earned ${completion.pointsEarned} points.${bonusNote}`, 'success');
            autoSave();
            safeRender();
        }

        function rejectTask(taskId, category, userId, reason = '') {
            const task = appState.tasks[category].find(t => t.id === taskId);
            if (!task || !task.completions[userId]) return;

            const completion = task.completions[userId];
            completion.status = 'rejected';
            completion.rejectedAt = new Date().toISOString();
            completion.rejectedBy = appState.currentUser.name;

            // Validate and truncate rejection reason
            const reasonResult = ValidationUtils.validateString(reason || 'Task needs to be redone', LIMITS.MAX_REJECTION_REASON_LENGTH, 'Rejection reason');
            completion.rejectionReason = reasonResult.value;

            showToast(`Task rejected: ${SecurityUtils.escapeHtml(completion.rejectionReason)}`, 'error');
            autoSave();
            safeRender();
        }

        function resubmitTask(taskId, category) {
            const task = appState.tasks[category].find(t => t.id === taskId);
            if (!task) return;

            const completion = task.completions[appState.currentUser.id];
            if (completion) {
                completion.status = 'pending';
                completion.resubmittedAt = new Date().toISOString();
                showToast('Task resubmitted for approval!', 'success');
                autoSave();
                safeRender();
            }
        }

        function resetTasks(category) {
            appState.tasks[category].forEach(task => {
                task.completions = {};
            });
            showToast(`${category} tasks reset!`, 'success');
            autoSave();
            safeRender();
        }

        function addTask(category) {
            // Check count limit for this category
            const check = ValidationUtils.canAddEntity(appState.tasks[category].length, LIMITS.MAX_TASKS_PER_CATEGORY, `tasks in ${category}`);
            if (!check.allowed) {
                showToast(check.error, 'warning');
                return;
            }

            const newTask = {
                id: Date.now(),
                name: 'New Task',
                assignee: 'Everyone',
                points: 5,
                timeEstimate: 10,
                completions: {},
                category,
                requiresEveryone: false
            };
            appState.tasks[category].push(newTask);
            appState.editingTask = newTask;
            safeRender();
        }

        function editTask(task) {
            appState.editingTask = { ...task };
            safeRender();
        }

        function saveTask() {
            const task = appState.editingTask;

            // Sanitize and validate task name
            task.name = SecurityUtils.sanitizeHtml(task.name || '').trim();
            if (!task.name) {
                showToast('Task name cannot be empty', 'warning');
                safeRender();
                return;
            }

            // Sanitize and validate assignee
            task.assignee = SecurityUtils.sanitizeHtml(task.assignee || '').trim();
            if (!task.assignee) {
                showToast('Assignee cannot be empty', 'warning');
                safeRender();
                return;
            }

            // Apply length and numeric validation with clamping
            const validation = ValidationUtils.validateTask(task);
            if (validation.warnings.length > 0) {
                console.warn('‚ö†Ô∏è Task validation warnings:', validation.warnings);
                showToast('Note: Some fields were adjusted to valid ranges: ' + validation.warnings.join(', '), 'info', 4000);
            }

            const taskIndex = appState.tasks[task.category].findIndex(t => t.id === task.id);
            if (taskIndex !== -1) {
                appState.tasks[task.category][taskIndex] = task;
            }
            appState.editingTask = null;
            autoSave();
            safeRender();
        }

        function deleteTask(taskId, category) {
            const task = appState.tasks[category].find(t => t.id === taskId);
            const taskName = task ? task.name : 'this task';

            appState.confirmDialog = {
                title: 'Delete Task',
                message: `Are you sure you want to delete "${taskName}"?\n\nThis will also remove:\n‚Ä¢ All completion records\n‚Ä¢ Streak/bonus data\n\nThis cannot be undone.`,
                onConfirm: () => {
                    appState.tasks[category] = appState.tasks[category].filter(t => t.id !== taskId);

                    // Clean up streak data for this task
                    StateCleanup.cleanupDeletedTasks(category, taskId);

                    appState.confirmDialog = null;
                    showToast('Task deleted successfully!', 'success');
                    autoSave();
                    safeRender();
                },
                onCancel: () => {
                    appState.confirmDialog = null;
                    safeRender();
                }
            };
            safeRender();
        }

        // Reward functions
        function redeemReward(rewardId) {
            const reward = appState.rewards.find(r => r.id === rewardId);
            const currentUser = getCurrentUser();

            if (currentUser.points >= reward.cost) {
                // For children: create pending reward request
                if (!currentUser.isParent) {
                    const pendingReward = {
                        id: Date.now(),
                        userId: currentUser.id,
                        userName: currentUser.name,
                        rewardId: reward.id,
                        rewardName: reward.name,
                        cost: reward.cost,
                        status: 'pending',
                        submittedAt: new Date().toISOString()
                    };
                    appState.pendingRewards.push(pendingReward);
                    showToast('Reward request submitted for parent approval!', 'success');
                    autoSave();
                    safeRender();
                } else {
                    // Parents can redeem immediately
                    const memberIndex = appState.familyMembers.findIndex(m => m.id === currentUser.id);
                    if (memberIndex !== -1) {
                        appState.familyMembers[memberIndex].points -= reward.cost;
                        appState.currentUser = appState.familyMembers[memberIndex];
                    }
                    showToast(`You redeemed: ${SecurityUtils.escapeHtml(reward.name)}! Enjoy!`, 'success');
                    autoSave();
                    safeRender();
                }
            } else {
                showToast(`You need ${reward.cost - currentUser.points} more points for this reward.`, 'warning');
                safeRender();
            }
        }

        function approveReward(requestId) {
            const request = appState.pendingRewards.find(r => r.id === requestId);
            if (!request) return;

            // Deduct points from user
            const memberIndex = appState.familyMembers.findIndex(m => m.id === request.userId);
            if (memberIndex !== -1) {
                appState.familyMembers[memberIndex].points -= request.cost;
            }

            // Update request status
            request.status = 'approved';
            request.approvedAt = new Date().toISOString();
            request.approvedBy = appState.currentUser.name;

            // Remove from pending list
            appState.pendingRewards = appState.pendingRewards.filter(r => r.id !== requestId);

            // Start timer if reward has timer enabled
            const reward = appState.rewards.find(r => r.id === request.rewardId);
            if (reward && reward.useTimer) {
                startRewardTimer(reward, request.userId, request.userName);
                showToast(`Reward approved! ${SecurityUtils.escapeHtml(request.userName)}'s timer is ready. Click "Start" to begin!`, 'success', 4000);
            } else {
                showToast(`Reward approved! ${SecurityUtils.escapeHtml(request.userName)} can now enjoy: ${SecurityUtils.escapeHtml(request.rewardName)}`, 'success');
            }

            autoSave();
            safeRender();
        }

        function rejectReward(requestId, reason = '') {
            const request = appState.pendingRewards.find(r => r.id === requestId);
            if (!request) return;

            // Update request status
            request.status = 'rejected';
            request.rejectedAt = new Date().toISOString();
            request.rejectedBy = appState.currentUser.name;
            request.rejectionReason = reason || 'Reward request not approved';

            // Remove from pending list
            appState.pendingRewards = appState.pendingRewards.filter(r => r.id !== requestId);

            showToast(`Reward rejected: ${SecurityUtils.escapeHtml(request.rejectionReason)}`, 'error');
            autoSave();
            safeRender();
        }

        function addReward() {
            // Check count limit
            const check = ValidationUtils.canAddEntity(appState.rewards.length, LIMITS.MAX_REWARDS, 'rewards');
            if (!check.allowed) {
                showToast(check.error, 'warning');
                return;
            }

            const newReward = {
                id: Date.now(),
                name: 'New Reward',
                cost: 10,
                category: 'General'
            };
            appState.rewards.push(newReward);
            appState.editingReward = newReward;
            safeRender();
        }

        function editReward(reward) {
            appState.editingReward = { ...reward };
            safeRender();
        }

        function saveReward() {
            const reward = appState.editingReward;

            // Sanitize and validate reward name
            reward.name = SecurityUtils.sanitizeHtml(reward.name || '').trim();
            if (!reward.name) {
                showToast('Reward name cannot be empty', 'warning');
                safeRender();
                return;
            }

            // Sanitize and validate category
            reward.category = SecurityUtils.sanitizeHtml(reward.category || '').trim();
            if (!reward.category) {
                showToast('Reward category cannot be empty', 'warning');
                safeRender();
                return;
            }

            // Validate timer settings if enabled
            if (reward.useTimer) {
                reward.timerMinutes = Math.max(1, Math.min(1440, parseInt(reward.timerMinutes) || 30));
                reward.extensionMinutes = Math.max(1, Math.min(120, parseInt(reward.extensionMinutes) || 10));
                reward.extensionCost = Math.max(1, Math.min(999, parseInt(reward.extensionCost) || 5));
                reward.playSoundOnFinish = !!reward.playSoundOnFinish;
            } else {
                // Ensure useTimer is explicitly false
                reward.useTimer = false;
            }

            // Apply length and numeric validation with clamping
            const validation = ValidationUtils.validateReward(reward);
            if (validation.warnings.length > 0) {
                console.warn('‚ö†Ô∏è Reward validation warnings:', validation.warnings);
                showToast('Note: Some fields were adjusted to valid ranges: ' + validation.warnings.join(', '), 'info', 4000);
            }

            const rewardIndex = appState.rewards.findIndex(r => r.id === reward.id);
            if (rewardIndex !== -1) {
                appState.rewards[rewardIndex] = reward;
            }
            appState.editingReward = null;
            autoSave();
            safeRender();
        }

        function deleteReward(rewardId) {
            const reward = appState.rewards.find(r => r.id === rewardId);
            const rewardName = reward ? reward.name : 'this reward';

            appState.confirmDialog = {
                title: 'Delete Reward',
                message: `Are you sure you want to delete "${rewardName}"?\n\nThis will also remove any pending reward requests for this reward.\n\nThis cannot be undone.`,
                onConfirm: () => {
                    appState.rewards = appState.rewards.filter(r => r.id !== rewardId);

                    // Clean up pending requests for this reward
                    StateCleanup.cleanupDeletedRewards(rewardId);

                    appState.confirmDialog = null;
                    showToast('Reward deleted successfully!', 'success');
                    autoSave();
                    safeRender();
                },
                onCancel: () => {
                    appState.confirmDialog = null;
                    safeRender();
                }
            };
            safeRender();
        }

        // ===== REWARD TIMER SYSTEM =====
        let timerInterval = null;

        // Play sound alert when timer finishes (plays 5 times)
        function playTimerSound() {
            // Create a simple beep using Web Audio API - play 5 times for more alarming effect
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const beepCount = 5;
                const beepDuration = 0.15;  // Each beep is 150ms
                const beepGap = 0.15;  // 150ms gap between beeps

                for (let i = 0; i < beepCount; i++) {
                    const startTime = audioContext.currentTime + (i * (beepDuration + beepGap));

                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    // Higher frequency for more alarming sound
                    oscillator.frequency.value = 880; // A5 note (higher pitch)
                    oscillator.type = 'square'; // Square wave is more attention-grabbing

                    // Envelope for the beep
                    gainNode.gain.setValueAtTime(0, startTime);
                    gainNode.gain.linearRampToValueAtTime(0.4, startTime + 0.01); // Quick attack
                    gainNode.gain.linearRampToValueAtTime(0.4, startTime + beepDuration - 0.05); // Hold
                    gainNode.gain.linearRampToValueAtTime(0, startTime + beepDuration); // Quick release

                    oscillator.start(startTime);
                    oscillator.stop(startTime + beepDuration);
                }
            } catch (error) {
                console.warn('Could not play timer sound:', error);
            }
        }

        // Format milliseconds to MM:SS
        function formatTimerTime(ms) {
            const totalSeconds = Math.ceil(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        // Initialize timer system
        function initRewardTimers() {
            // Start global timer tick
            if (!timerInterval) {
                timerInterval = setInterval(updateTimersTick, 1000);
            }
        }

        // Start a new reward timer
        function startRewardTimer(reward, userId, userName) {
            const durationMs = reward.timerMinutes * 60 * 1000;
            const now = Date.now();

            const timer = {
                id: now,
                rewardId: reward.id,
                rewardName: reward.name,
                userId: userId,
                userName: userName,
                durationMs: durationMs,
                remainingMs: durationMs,
                startedAt: new Date().toISOString(),
                paused: true,  // Start paused - user must manually start
                started: false,  // Track if timer has ever been started
                lastTick: now,
                extendedBy: 0,
                costPerExtension: reward.extensionCost || 5,
                extensionMinutes: reward.extensionMinutes || 10,
                playSoundOnFinish: reward.playSoundOnFinish !== false,
                collapsed: false
            };

            appState.activeRewardTimers.push(timer);
            autoSave();
            safeRender();
        }

        // Start a paused timer for the first time
        function startTimer(timerId) {
            const timer = appState.activeRewardTimers.find(t => t.id === timerId);
            if (timer) {
                timer.paused = false;
                timer.started = true;
                timer.lastTick = Date.now();
                showToast('Timer started!', 'success');
                autoSave();
                updateTimerControls(timerId);
            }
        }

        // Update timer control buttons without full render
        function updateTimerControls(timerId) {
            const timer = appState.activeRewardTimers.find(t => t.id === timerId);
            if (!timer) return;

            // Update buttons in floating panel
            const timerCard = document.querySelector(`[data-timer-id="${timerId}"]`);
            if (timerCard) {
                const controlsDiv = timerCard.querySelector('.timer-card-controls');
                if (controlsDiv) {
                    let controlButton = '';
                    if (!timer.started) {
                        controlButton = `<button class="btn btn-success btn-small" onclick="event.stopPropagation(); startTimer(${timer.id})" style="flex: 1;">‚ñ∂Ô∏è Start</button>`;
                    } else if (timer.paused) {
                        controlButton = `<button class="btn btn-success btn-small" onclick="event.stopPropagation(); resumeTimer(${timer.id})" style="flex: 1;">‚ñ∂Ô∏è Resume</button>`;
                    } else {
                        controlButton = `<button class="btn btn-warning btn-small" onclick="event.stopPropagation(); pauseTimer(${timer.id})" style="flex: 1;">‚è∏Ô∏è Pause</button>`;
                    }
                    controlsDiv.innerHTML = `
                        ${controlButton}
                        <button class="btn btn-primary btn-small" onclick="event.stopPropagation(); openTimerDrawer(${timer.id})" style="flex: 1;">‚öôÔ∏è Details</button>
                    `;
                }

                // Update paused class
                if (timer.paused) {
                    timerCard.classList.add('paused');
                } else {
                    timerCard.classList.remove('paused');
                }
            }

            // Update buttons in drawer if open
            if (appState.timerDrawer === timerId) {
                const drawerActions = document.querySelector('#timer-drawer .timer-drawer-actions');
                if (drawerActions) {
                    let buttonHTML = '';
                    if (!timer.started) {
                        buttonHTML = `<button class="btn btn-success" onclick="startTimer(${timer.id})">‚ñ∂Ô∏è Start Timer</button>`;
                    } else if (timer.paused) {
                        buttonHTML = `<button class="btn btn-success" onclick="resumeTimer(${timer.id})">‚ñ∂Ô∏è Resume</button>`;
                    } else {
                        buttonHTML = `<button class="btn btn-warning" onclick="pauseTimer(${timer.id})">‚è∏Ô∏è Pause</button>`;
                    }
                    drawerActions.innerHTML = `
                        ${buttonHTML}
                        <button class="btn btn-primary" onclick="extendTimer(${timer.id})">‚è±Ô∏è Extend</button>
                    `;
                }

                const drawerLabel = document.querySelector('#timer-drawer .timer-center-label');
                if (drawerLabel) {
                    drawerLabel.textContent = timer.paused ? 'Paused' : 'Remaining';
                }
            }
        }

        // Update all timers (called every second)
        function updateTimersTick() {
            if (appState.activeRewardTimers.length === 0) return;

            const now = Date.now();
            const finishedTimers = [];
            let needsFullRender = false;

            appState.activeRewardTimers = appState.activeRewardTimers.filter(timer => {
                if (timer.paused) return true;

                // Calculate elapsed time since last tick
                const elapsed = now - timer.lastTick;
                timer.remainingMs -= elapsed;
                timer.lastTick = now;

                // Check if finished
                if (timer.remainingMs <= 0) {
                    finishedTimers.push(timer);
                    needsFullRender = true;
                    return false; // Remove from array
                }

                return true; // Keep in array
            });

            // Handle finished timers
            finishedTimers.forEach(timer => {
                // Close drawer if it's open for this timer to prevent white page
                if (appState.timerDrawer === timer.id) {
                    closeTimerDrawer();
                }

                showToast(`‚è∞ Timer finished: ${SecurityUtils.escapeHtml(timer.rewardName)} for ${SecurityUtils.escapeHtml(timer.userName)}`, 'info', 5000);
                if (timer.playSoundOnFinish) {
                    playTimerSound();
                }
            });

            // Only do full render if timers finished, otherwise just update displays
            if (needsFullRender) {
                autoSave();
                safeRender();
            } else if (appState.activeRewardTimers.length > 0) {
                // Update timer displays in DOM without full render
                updateTimerDisplays();
                // Save state every tick for running timers to ensure persistence on page refresh
                autoSave();
            }
        }

        // Update timer displays in DOM without full re-render
        function updateTimerDisplays() {
            appState.activeRewardTimers.forEach(timer => {
                const timeRemaining = formatTimerTime(timer.remainingMs);

                // Update in floating panel
                const panelTimeElements = document.querySelectorAll(`[data-timer-id="${timer.id}"] .timer-card-time`);
                panelTimeElements.forEach(el => {
                    if (el) {
                        el.textContent = timeRemaining;

                        // Update color class based on time remaining
                        const totalSeconds = Math.ceil(timer.remainingMs / 1000);
                        const totalMinutes = Math.floor(totalSeconds / 60);

                        el.classList.remove('warning', 'danger');
                        if (totalMinutes < 1) el.classList.add('danger');
                        else if (totalMinutes < 5) el.classList.add('warning');
                    }
                });

                // Update in drawer if open
                if (appState.timerDrawer === timer.id) {
                    const drawerTimeEl = document.querySelector('#timer-drawer .timer-center-time');
                    if (drawerTimeEl) {
                        drawerTimeEl.textContent = timeRemaining;
                    }

                    // Update progress ring
                    const progress = (timer.remainingMs / timer.durationMs) * 100;
                    const radius = 88;
                    const circumference = 2 * Math.PI * radius;
                    const offset = circumference - (progress / 100) * circumference;

                    const progressCircle = document.querySelector('#timer-drawer .progress');
                    if (progressCircle) {
                        progressCircle.setAttribute('stroke-dashoffset', offset);
                    }
                }
            });
        }

        // Pause a timer
        function pauseTimer(timerId) {
            const timer = appState.activeRewardTimers.find(t => t.id === timerId);
            if (timer) {
                timer.paused = true;
                showToast('Timer paused', 'info');
                autoSave();
                updateTimerControls(timerId);
            }
        }

        // Resume a timer
        function resumeTimer(timerId) {
            const timer = appState.activeRewardTimers.find(t => t.id === timerId);
            if (timer) {
                timer.paused = false;
                timer.lastTick = Date.now(); // Reset last tick to prevent jump
                showToast('Timer resumed', 'success');
                autoSave();
                updateTimerControls(timerId);
            }
        }

        // Extend a timer
        function extendTimer(timerId) {
            const timer = appState.activeRewardTimers.find(t => t.id === timerId);
            if (!timer) return;

            const user = appState.familyMembers.find(m => m.id === timer.userId);
            if (!user) return;

            const extensionMs = timer.extensionMinutes * 60 * 1000;

            // Check if user has enough points
            if (user.points < timer.costPerExtension) {
                showToast(`Not enough points! Need ${timer.costPerExtension} points to extend timer.`, 'warning');
                return;
            }

            // Confirm extension
            const confirmMsg = `Extend timer by ${timer.extensionMinutes} minutes for ${timer.costPerExtension} points?`;
            if (!confirm(confirmMsg)) return;

            // Deduct points
            const memberIndex = appState.familyMembers.findIndex(m => m.id === timer.userId);
            if (memberIndex !== -1) {
                appState.familyMembers[memberIndex].points -= timer.costPerExtension;
            }

            // Extend timer
            timer.remainingMs += extensionMs;
            timer.extendedBy += extensionMs;

            showToast(`Timer extended by ${timer.extensionMinutes} minutes!`, 'success');
            autoSave();

            // Update timer displays without full render
            updateTimerDisplays();

            // Update drawer info if open
            if (appState.timerDrawer === timerId) {
                const totalExtendedMinutes = Math.floor(timer.extendedBy / (60 * 1000));
                const extendedRow = document.querySelector('#timer-drawer .timer-drawer-info-row:has(.timer-drawer-info-label)');

                // Update available points
                const pointsValue = document.querySelector('#timer-drawer .timer-drawer-info-row:last-child .timer-drawer-info-value');
                if (pointsValue) {
                    pointsValue.textContent = `${user.points} pts`;
                }
            }
        }

        // Cancel a timer
        function cancelTimer(timerId) {
            const timer = appState.activeRewardTimers.find(t => t.id === timerId);
            if (!timer) return;

            const confirmMsg = `Cancel timer for "${timer.rewardName}"? This cannot be undone.`;
            if (!confirm(confirmMsg)) return;

            appState.activeRewardTimers = appState.activeRewardTimers.filter(t => t.id !== timerId);
            showToast('Timer cancelled', 'info');
            autoSave();
            safeRender();
        }

        // Toggle timer panel collapse
        function toggleTimerPanel() {
            appState.timerPanelCollapsed = !appState.timerPanelCollapsed;
            safeRender();
        }

        // Open timer drawer
        function openTimerDrawer(timerId) {
            appState.timerDrawer = timerId;

            // Remove existing drawer if present
            const existingDrawerOverlay = document.getElementById('timer-drawer-overlay');
            const existingDrawer = document.getElementById('timer-drawer');
            if (existingDrawerOverlay) existingDrawerOverlay.remove();
            if (existingDrawer) existingDrawer.remove();

            // Add new drawer
            const drawerHTML = renderTimerDrawer();
            if (drawerHTML) {
                document.body.insertAdjacentHTML('beforeend', drawerHTML);
            }
        }

        // Close timer drawer
        function closeTimerDrawer() {
            appState.timerDrawer = null;

            // Remove drawer elements
            const drawerOverlay = document.getElementById('timer-drawer-overlay');
            const drawer = document.getElementById('timer-drawer');
            if (drawerOverlay) drawerOverlay.remove();
            if (drawer) drawer.remove();
        }

        // Toggle individual timer collapse in panel
        function toggleTimerCollapse(timerId) {
            const timer = appState.activeRewardTimers.find(t => t.id === timerId);
            if (timer) {
                timer.collapsed = !timer.collapsed;
                safeRender();
            }
        }

        // Drag functionality for timer panel (desktop only)
        let isDraggingPanel = false;
        let panelDragStartX = 0;
        let panelDragStartY = 0;

        function handleTimerPanelDragStart(e) {
            // Only enable dragging on desktop (min-width: 768px)
            if (window.innerWidth < 768) return;

            e.preventDefault();
            isDraggingPanel = true;

            const panel = document.getElementById('floating-timer-panel');
            if (!panel) return;

            panel.classList.add('dragging');

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const rect = panel.getBoundingClientRect();
            panelDragStartX = clientX - rect.left;
            panelDragStartY = clientY - rect.top;

            document.addEventListener('mousemove', handleTimerPanelDrag);
            document.addEventListener('mouseup', handleTimerPanelDragEnd);
            document.addEventListener('touchmove', handleTimerPanelDrag);
            document.addEventListener('touchend', handleTimerPanelDragEnd);
        }

        function handleTimerPanelDrag(e) {
            if (!isDraggingPanel) return;

            const panel = document.getElementById('floating-timer-panel');
            if (!panel) return;

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            let newX = clientX - panelDragStartX;
            let newY = clientY - panelDragStartY;

            // Constrain to viewport
            const maxX = window.innerWidth - panel.offsetWidth;
            const maxY = window.innerHeight - panel.offsetHeight;

            newX = Math.max(0, Math.min(newX, maxX));
            newY = Math.max(0, Math.min(newY, maxY));

            panel.style.left = newX + 'px';
            panel.style.top = newY + 'px';
            panel.style.right = 'auto';
            panel.style.bottom = 'auto';

            appState.timerPanelPosition = { x: newX, y: newY };
        }

        function handleTimerPanelDragEnd() {
            if (!isDraggingPanel) return;

            isDraggingPanel = false;

            const panel = document.getElementById('floating-timer-panel');
            if (panel) {
                panel.classList.remove('dragging');
            }

            document.removeEventListener('mousemove', handleTimerPanelDrag);
            document.removeEventListener('mouseup', handleTimerPanelDragEnd);
            document.removeEventListener('touchmove', handleTimerPanelDrag);
            document.removeEventListener('touchend', handleTimerPanelDragEnd);

            autoSave();
        }

        // Member functions
        function addMember() {
            // Check count limit
            const check = ValidationUtils.canAddEntity(appState.familyMembers.length, LIMITS.MAX_FAMILY_MEMBERS, 'family members');
            if (!check.allowed) {
                showToast(check.error, 'warning');
                return;
            }

            const newMember = {
                id: Date.now(),
                name: 'New Member',
                avatar: 'üë§',
                points: 0,
                isParent: false,
                role: 'child',
                password: 'password123'
            };
            appState.familyMembers.push(newMember);
            appState.editingMember = newMember;
            safeRender();
        }

        function editMember(member) {
            appState.editingMember = { ...member };
            safeRender();
        }

        function saveMember() {
            const member = appState.editingMember;

            // Sanitize and validate member name
            member.name = SecurityUtils.sanitizeHtml(member.name || '').trim();
            if (!member.name) {
                showToast('Member name cannot be empty', 'warning');
                safeRender();
                return;
            }

            // Sanitize password (allow it to be empty but sanitize if present)
            member.password = SecurityUtils.sanitizeHtml(member.password || '').trim();

            // Apply length and numeric validation with clamping
            const validation = ValidationUtils.validateMember(member);
            if (validation.warnings.length > 0) {
                console.warn('‚ö†Ô∏è Member validation warnings:', validation.warnings);
                showToast('Note: Some fields were adjusted to valid ranges: ' + validation.warnings.join(', '), 'info', 4000);
            }

            const memberIndex = appState.familyMembers.findIndex(m => m.id === member.id);
            if (memberIndex !== -1) {
                appState.familyMembers[memberIndex] = member;
                if (appState.currentUser && appState.currentUser.id === member.id) {
                    appState.currentUser = member;
                }
            }
            appState.editingMember = null;
            autoSave();
            safeRender();
        }

        function deleteMember(memberId) {
            if (!validateParentAccess('delete family members')) return;
            if (appState.familyMembers.length <= 1) {
                showToast('Cannot delete the last family member!', 'warning');
                return;
            }

            const memberToDelete = appState.familyMembers.find(m => m.id === memberId);
            const memberName = memberToDelete ? memberToDelete.name : 'this member';

            appState.confirmDialog = {
                title: 'Delete Family Member',
                message: `Are you sure you want to delete ${memberName}?\n\nThis will also remove:\n‚Ä¢ All task completions and streaks\n‚Ä¢ Login attempt history\n‚Ä¢ Pending reward requests\n‚Ä¢ Associated passwords and settings\n\nThis cannot be undone.`,
                onConfirm: () => {
                    appState.familyMembers = appState.familyMembers.filter(m => m.id !== memberId);

                    // Clean up orphaned data
                    StateCleanup.cleanupDeletedMembers();

                    appState.confirmDialog = null;
                    showToast('Family member deleted successfully!', 'success');
                    autoSave();
                    safeRender();
                },
                onCancel: () => {
                    appState.confirmDialog = null;
                    safeRender();
                }
            };
            safeRender();
        }

        // Password visibility toggle
        function toggleMemberPassword(memberId) {
            appState.showMemberPasswords[memberId] = !appState.showMemberPasswords[memberId];
            safeRender();
        }

        // Modal functions
        function handleModalBackdropClick(event) {
            // Only handle clicks on the backdrop itself (not its children)
            if (event.target.classList.contains('modal')) {
                // Check if this is a confirm dialog - these should NOT close on backdrop click
                if (appState.confirmDialog) {
                    return; // Do nothing - confirm dialogs require explicit button click
                }

                // For editor modals, show confirmation before closing
                if (appState.editingTask || appState.editingReward || appState.editingMember) {
                    if (confirm('Close without saving?')) {
                        closeModal();
                    }
                }
            }
        }

        function closeModal() {
            appState.editingTask = null;
            appState.editingReward = null;
            appState.editingMember = null;
            appState.confirmDialog = null;
            safeRender();
        }

        // Render functions
        function renderLogin() {
            const selectedMember = appState.familyMembers.find(m => m.id === appState.selectedUserId);
            const attempts = appState.loginAttempts[appState.selectedUserId] || { count: 0, lastAttempt: 0 };

            // Use manipulation-resistant timestamp
            const now = TimeUtils.now();

            // Check for global lockout
            const globalLockout = GlobalSecurity.isGloballyLocked();

            const lockoutExpired = attempts.count >= appState.settings.maxLoginAttempts &&
                                  (now - attempts.lastAttempt) >= appState.settings.lockoutTime;
            const isLocked = attempts.count >= appState.settings.maxLoginAttempts &&
                           (now - attempts.lastAttempt) < appState.settings.lockoutTime;

            // If lockout expired, treat counter as reset for display
            const displayAttempts = lockoutExpired ? 0 : attempts.count;

            return `
                <div class="login-screen">
                    <div class="login-card">
                        <h1 class="text-center">üè† Family Cleaning Hub</h1>
                        
                        ${!appState.selectedUserId ? `
                            <h2 class="text-center text-gray">Select your profile:</h2>
                            
                            ${appState.familyMembers.map(member => {
                                const role = member.role || (member.isParent ? 'parent' : 'child');
                                const roleLabel = role.charAt(0).toUpperCase() + role.slice(1);
                                const safeName = SecurityUtils.escapeHtml(member.name);
                                return `
                                    <div class="member-btn" onclick="selectUser(${member.id})">
                                        <span style="font-size: 24px;">${member.avatar}</span>
                                        <div>
                                            <div style="font-weight: 500;">${safeName}</div>
                                            <div class="text-gray">${member.points} points ‚Ä¢ ${roleLabel}</div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        ` : `
                            <div style="text-align: center; margin-bottom: 20px;">
                                <span style="font-size: 48px;">${selectedMember.avatar}</span>
                                <h2>${SecurityUtils.escapeHtml(selectedMember.name)}</h2>
                                <p class="text-gray">${(() => {
                                    const role = selectedMember.role || (selectedMember.isParent ? 'parent' : 'child');
                                    return role.charAt(0).toUpperCase() + role.slice(1) + ' Account';
                                })()}</p>
                            </div>
                            
                            <div style="margin-bottom: 20px;">
                                <input
                                    type="${appState.showPassword ? 'text' : 'password'}"
                                    placeholder="Enter your password"
                                    class="admin-input"
                                    value="${appState.userPassword}"
                                    oninput="appState.userPassword = this.value"
                                    onkeydown="if(event.key==='Enter') attemptLogin()"
                                    ${isLocked || globalLockout.isLocked ? 'disabled' : ''}
                                    style="width: 100%; margin-bottom: 10px;"
                                />

                                ${globalLockout.isLocked ? `
                                    <div style="background: #450a0a; border: 2px solid #ef4444; border-radius: 5px; padding: 10px; margin-bottom: 10px; font-size: 13px; color: #fca5a5;">
                                        ‚ö†Ô∏è <strong>SECURITY ALERT</strong><br/>
                                        Too many failed login attempts from this device.<br/>
                                        Device locked for ${Math.ceil(globalLockout.remainingTime / 60000)} more minutes.
                                    </div>
                                ` : isLocked ? `
                                    <div style="background: #fef2f2; border: 1px solid #ef4444; border-radius: 5px; padding: 8px; margin-bottom: 10px; font-size: 12px; color: #dc2626;">
                                        üîí Account locked for 5 minutes due to too many failed attempts
                                    </div>
                                ` : displayAttempts > 0 ? `
                                    <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 5px; padding: 8px; margin-bottom: 10px; font-size: 12px; color: #92400e;">
                                        ‚ö†Ô∏è ${displayAttempts}/${appState.settings.maxLoginAttempts} failed attempts
                                    </div>
                                ` : ''}

                                <div class="flex gap-2">
                                    <button class="btn btn-secondary" onclick="appState.showPassword = !appState.showPassword; render()">
                                        ${appState.showPassword ? 'üôà' : 'üëÅÔ∏è'}
                                    </button>
                                    <button class="btn btn-primary" onclick="attemptLogin()" ${isLocked || globalLockout.isLocked ? 'disabled' : ''} style="flex: 1;">
                                        üîë Login
                                    </button>
                                </div>
                                
                                <button class="btn btn-secondary" onclick="appState.selectedUserId = null; appState.userPassword = ''; render()" 
                                        style="width: 100%; margin-top: 10px;">
                                    ‚Üê Back to User Selection
                                </button>
                            </div>
                            
                            ${selectedMember.isParent ? `
                                <div style="font-size: 12px; color: #6b7280; text-align: center; margin-top: 15px;">
                                    üí° Parents automatically access the admin panel
                                </div>
                            ` : ''}
                        `}
                    </div>
                </div>
            `;
        }

        function renderTaskCard(task, category) {
            const currentUser = getCurrentUser();
            const canComplete = isTaskAssignedToUser(task, currentUser);
            const userCompletion = task.completions[currentUser?.id];
            const completedCount = Object.keys(task.completions || {}).length;

            // Bonus / streak info for current user
            var hasBonusActive = task.bonusEnabled && task.category !== 'monthly' && !currentUser.isParent;
            var bonusCalc = hasBonusActive ? calculateBonusMultiplier(task, currentUser.id) : null;
            var currentStreak = hasBonusActive ? getStreakInfo(task.id, currentUser.id) : null;

            // Get completion status for current user
            let userStatus = 'not_started';
            if (userCompletion) {
                userStatus = userCompletion.status;
            }

            // Sanitize user-generated content
            const safeTaskName = SecurityUtils.escapeHtml(task.name);
            const safeAssignee = SecurityUtils.escapeHtml(task.assignee);
            const safeRejectionReason = SecurityUtils.escapeHtml(userCompletion?.rejectionReason);

            return `
                <div class="task-card ${userStatus === 'approved' ? 'completed' : userStatus === 'pending' ? 'pending' : userStatus === 'rejected' ? 'rejected' : ''}">
                    <div class="task-header">
                        <div>
                            <div class="task-title">${safeTaskName}</div>
                            ${task.requiresEveryone ? '<span style="font-size: 12px; background: #dbeafe; color: #1e40af; padding: 2px 6px; border-radius: 10px;">Individual task</span>' : ''}
                            ${hasBonusActive && bonusCalc && bonusCalc.multiplier > 1.0 ? `<span class="bonus-badge">üî• ${bonusCalc.multiplier}x Bonus</span>` : ''}
                            ${hasBonusActive && task.bonusStreakBadge !== false && currentStreak && currentStreak.count > 0 ? `<span class="streak-badge">üåü ${currentStreak.count} streak</span>` : ''}
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span class="task-points">${Math.round(task.points * appState.settings.pointMultiplier)} pts</span>
                            <span style="font-size: 12px; color: #6b7280;">‚è∞ ${task.timeEstimate}min</span>
                        </div>
                    </div>

                    <div class="task-assignee">üë§ ${safeAssignee}</div>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 15px;">
                        ${task.requiresEveryone ?
                            `Completed: ${Object.values(task.completions).filter(c => c.status === 'approved').length}/${appState.familyMembers.filter(m => !m.isParent).length}` :
                            Object.values(task.completions).filter(c => c.status === 'approved').length > 0 ?
                                `Done by ${Object.values(task.completions).filter(c => c.status === 'approved').map(c => SecurityUtils.escapeHtml(c.name)).join(', ')}` :
                                'Not completed'
                        }
                    </div>

                    ${userCompletion && userStatus === 'pending' ? `
                        <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 5px; padding: 8px; margin-bottom: 10px; font-size: 12px;">
                            ‚è≥ Waiting for parent approval (submitted ${DateUtils.formatRelative(userCompletion.submittedAt)})
                        </div>
                    ` : ''}

                    ${userCompletion && userStatus === 'rejected' ? `
                        <div style="background: #fef2f2; border: 1px solid #ef4444; border-radius: 5px; padding: 8px; margin-bottom: 10px; font-size: 12px;">
                            ‚ùå Task rejected: ${safeRejectionReason || 'Needs to be redone'}
                        </div>
                    ` : ''}
                    
                    <div class="task-actions">
                        ${userStatus === 'not_started' && canComplete ? `
                            <button class="btn btn-success" onclick="completeTask(${task.id}, '${category}')">
                                ‚úÖ ${currentUser.isParent ? 'Complete' : 'Submit for Approval'}
                            </button>
                        ` : ''}
                        
                        ${userStatus === 'pending' && !currentUser.isParent ? `
                            <span style="color: #f59e0b; font-weight: 500;">‚è≥ Pending Approval</span>
                        ` : ''}
                        
                        ${userStatus === 'approved' ? `
                            <span style="color: #10b981; font-weight: 500;">‚úÖ Completed & Approved!</span>
                        ` : ''}
                        
                        ${userStatus === 'rejected' && !currentUser.isParent ? `
                            <button class="btn btn-primary" onclick="resubmitTask(${task.id}, '${category}')">
                                üîÑ Resubmit
                            </button>
                        ` : ''}
                    </div>
                </div>
            `;
        }

        function renderDataManagement() {
            const storageInfo = getStorageInfo();
            
            return `
                <div class="data-management">
                    <h4 style="margin-bottom: 10px;">üíæ Data Management</h4>
                    
                    <div class="storage-status">
                        <div class="status-indicator ${storageInfo.exists ? 'active' : 'inactive'}"></div>
                        <span style="font-size: 14px;">
                            ${storageInfo.exists ?
                                `Auto-save active (${storageInfo.size}, saved ${DateUtils.formatRelative(storageInfo.timestamp)})` :
                                'No saved data found'
                            }
                        </span>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; margin-bottom: 10px;">
                        <button class="btn btn-primary btn-small" onclick="exportData()">
                            üì§ Export Backup
                        </button>
                        
                        <label class="btn btn-success btn-small file-label" for="importFile">
                            üì• Import Backup
                        </label>
                        <input type="file" id="importFile" class="file-input" accept=".json" onchange="importData(event)" />
                        
                        <button class="btn btn-warning btn-small" onclick="
                            if(confirm('Manually save current data?')) {
                                const result = saveToStorage();
                                if(result.success) {
                                    stateHash = calculateStateHash();
                                    hasUnsavedChanges = false;
                                    showToast('Data saved successfully!', 'success');
                                } else {
                                    showToast(result.error || 'Failed to save data!', 'error');
                                }
                                safeRender();
                            }
                        ">
                            üíæ Save Now
                        </button>
                        
                        <button class="btn btn-danger btn-small" onclick="clearAllData()">
                            üóëÔ∏è Clear All
                        </button>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                        <input type="checkbox" ${appState.settings.autoSave ? 'checked' : ''} 
                               onchange="appState.settings.autoSave = this.checked; autoSave();" />
                        <label style="font-size: 14px; margin: 0;">Auto-save changes</label>
                    </div>
                    
                    <div class="data-info">
                        üí° Export creates a backup file you can save safely. Import lets you restore from a backup file. 
                        Auto-save keeps your progress automatically. All data is stored locally in your browser.
                    </div>
                </div>
            `;
        }

        function renderTaskEditor() {
            if (!appState.editingTask) return '';

            const task = appState.editingTask;

            // Sanitize for display in input value attributes
            const safeTaskName = SecurityUtils.escapeHtml(task.name);

            return `
                <div class="modal" onclick="handleModalBackdropClick(event)">
                    <div class="modal-content" onclick="event.stopPropagation()">
                        <h3>Edit Task</h3>

                        <div class="form-group">
                            <label>Task Name</label>
                            <input type="text" value="${safeTaskName}" onchange="appState.editingTask.name = this.value" />
                        </div>

                        <div class="form-group">
                            <label>Assignee</label>
                            <select onchange="appState.editingTask.assignee = this.value">
                                <option value="Everyone" ${task.assignee === 'Everyone' ? 'selected' : ''}>Everyone</option>
                                <option value="Kids" ${task.assignee === 'Kids' ? 'selected' : ''}>Kids</option>
                                <option value="Parents" ${task.assignee === 'Parents' ? 'selected' : ''}>Parents</option>
                                <option value="Parents + Teens" ${task.assignee === 'Parents + Teens' ? 'selected' : ''}>Parents + Teens</option>
                                <option value="Parents + Children" ${task.assignee === 'Parents + Children' ? 'selected' : ''}>Parents + Children</option>
                                ${appState.familyMembers.map(member => {
                                    const safeMemberName = SecurityUtils.escapeHtml(member.name);
                                    return `
                                        <option value="${safeMemberName}" ${task.assignee === member.name ? 'selected' : ''}>${safeMemberName}</option>
                                    `;
                                }).join('')}
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <div class="checkbox-group">
                                <input type="checkbox" ${task.requiresEveryone ? 'checked' : ''} 
                                       onchange="appState.editingTask.requiresEveryone = this.checked" />
                                <label>Everyone does this individually (like making beds)</label>
                            </div>
                        </div>
                        
                        <div class="form-row">
                            <div class="form-group">
                                <label>Points</label>
                                <input type="number" value="${task.points}" onchange="appState.editingTask.points = parseInt(this.value) || 0" />
                            </div>
                            <div class="form-group">
                                <label>Time (minutes)</label>
                                <input type="number" value="${task.timeEstimate}" onchange="appState.editingTask.timeEstimate = parseInt(this.value) || 0" />
                            </div>
                        </div>
                        
                        ${task.category !== 'monthly' ? `
                        <div class="form-group">
                            <div class="checkbox-group">
                                <input type="checkbox" id="bonusToggle" ${task.bonusEnabled ? 'checked' : ''}
                                       onchange="appState.editingTask.bonusEnabled = this.checked; render()" />
                                <label style="margin: 0;">Enable Consecutive Completion Bonus</label>
                            </div>
                            ${task.bonusEnabled ? `
                            <div class="bonus-config">
                                <div class="checkbox-group" style="margin-bottom: 8px;">
                                    <label>Base Multiplier:</label>
                                    <input type="number" step="0.1" min="1.1" max="5.0"
                                           value="${task.bonusBaseMultiplier || 1.5}"
                                           onchange="appState.editingTask.bonusBaseMultiplier = Math.max(1.1, parseFloat(this.value) || 1.5); render()" />
                                    <span style="font-size: 12px; color: #92400e;">x points on streak</span>
                                </div>
                                <div class="checkbox-group" style="margin-bottom: 8px;">
                                    <input type="checkbox" ${task.bonusEscalating ? 'checked' : ''}
                                           onchange="appState.editingTask.bonusEscalating = this.checked; render()" />
                                    <label style="margin: 0;">Escalating multiplier (grows each streak)</label>
                                </div>
                                ${task.bonusEscalating ? `
                                <div class="sub-options">
                                    <div class="checkbox-group" style="margin-bottom: 4px;">
                                        <label>Max escalation steps:</label>
                                        <input type="number" step="1" min="1" max="10"
                                               value="${task.bonusMaxEscalations || 3}"
                                               onchange="appState.editingTask.bonusMaxEscalations = Math.max(1, parseInt(this.value) || 3); render()" />
                                    </div>
                                    <div style="font-size: 12px; color: #92400e;">
                                        Cap: ${(() => { var b = task.bonusBaseMultiplier || 1.5; var s = b - 1.0; var m = task.bonusMaxEscalations || 3; return (1.0 + s + m * s).toFixed(2); })()}x after ${task.bonusMaxEscalations || 3} streak${(task.bonusMaxEscalations || 3) === 1 ? '' : 's'}
                                    </div>
                                </div>
                                ` : ''}
                                <div class="checkbox-group" style="margin-top: 8px;">
                                    <input type="checkbox" ${task.bonusStreakBadge !== false ? 'checked' : ''}
                                           onchange="appState.editingTask.bonusStreakBadge = this.checked" />
                                    <label style="margin: 0;">Show streak badge on task card</label>
                                </div>
                            </div>
                            ` : ''}
                        </div>
                        ` : ''}

                        <div class="modal-buttons">
                            <button class="btn btn-success" onclick="saveTask()">üíæ Save</button>
                            <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderRewardEditor() {
            if (!appState.editingReward) return '';

            const reward = appState.editingReward;

            // Ensure timer defaults exist
            if (reward.useTimer === undefined) reward.useTimer = false;
            if (reward.timerMinutes === undefined) reward.timerMinutes = 30;
            if (reward.extensionMinutes === undefined) reward.extensionMinutes = 10;
            if (reward.extensionCost === undefined) reward.extensionCost = 5;
            if (reward.playSoundOnFinish === undefined) reward.playSoundOnFinish = true;

            // Sanitize for display in input value attributes
            const safeRewardName = SecurityUtils.escapeHtml(reward.name);
            const safeRewardCategory = SecurityUtils.escapeHtml(reward.category);

            return `
                <div class="modal" onclick="handleModalBackdropClick(event)">
                    <div class="modal-content" onclick="event.stopPropagation()">
                        <h3>Edit Reward</h3>

                        <div class="form-group">
                            <label>Reward Name</label>
                            <input type="text" value="${safeRewardName}" onchange="appState.editingReward.name = this.value" />
                        </div>

                        <div class="form-group">
                            <label>Category</label>
                            <input type="text" value="${safeRewardCategory}" onchange="appState.editingReward.category = this.value" />
                        </div>

                        <div class="form-group">
                            <label>Point Cost</label>
                            <input type="number" value="${reward.cost}" onchange="appState.editingReward.cost = parseInt(this.value) || 0" />
                        </div>

                        <div class="form-group">
                            <div class="checkbox-group">
                                <input type="checkbox" id="useTimer" ${reward.useTimer ? 'checked' : ''}
                                    onchange="appState.editingReward.useTimer = this.checked; render();" />
                                <label for="useTimer">‚è±Ô∏è Enable Timer for this Reward</label>
                            </div>
                        </div>

                        ${reward.useTimer ? `
                            <div class="timer-config">
                                <div class="form-group">
                                    <label>Timer Duration (minutes)</label>
                                    <div class="timer-slider-container">
                                        <input type="range" class="timer-slider" min="1" max="1440"
                                            value="${reward.timerMinutes}"
                                            oninput="appState.editingReward.timerMinutes = parseInt(this.value); render();" />
                                        <input type="number" class="timer-minutes-input" min="1" max="1440"
                                            value="${reward.timerMinutes}"
                                            onchange="appState.editingReward.timerMinutes = Math.max(1, Math.min(1440, parseInt(this.value) || 30)); render();" />
                                    </div>
                                    <small style="color: #6b7280;">How long the timer runs (1-1440 minutes)</small>
                                </div>

                                <div class="sub-options">
                                    <div class="form-group">
                                        <label>Extension Duration (minutes)</label>
                                        <input type="number" min="1" max="120" value="${reward.extensionMinutes}"
                                            onchange="appState.editingReward.extensionMinutes = Math.max(1, Math.min(120, parseInt(this.value) || 10));" />
                                        <small style="color: #6b7280;">How many minutes added per extension</small>
                                    </div>

                                    <div class="form-group">
                                        <label>Extension Cost (points)</label>
                                        <input type="number" min="1" max="999" value="${reward.extensionCost}"
                                            onchange="appState.editingReward.extensionCost = Math.max(1, Math.min(999, parseInt(this.value) || 5));" />
                                        <small style="color: #6b7280;">Point cost to extend the timer</small>
                                    </div>

                                    <div class="form-group">
                                        <div class="checkbox-group">
                                            <input type="checkbox" id="playSoundOnFinish" ${reward.playSoundOnFinish ? 'checked' : ''}
                                                onchange="appState.editingReward.playSoundOnFinish = this.checked;" />
                                            <label for="playSoundOnFinish">üîî Play sound alert when timer finishes</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        ` : ''}

                        <div class="modal-buttons">
                            <button class="btn btn-success" onclick="saveReward()">üíæ Save</button>
                            <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderMemberEditor() {
            if (!appState.editingMember) return '';

            const member = appState.editingMember;
            const avatarOptions = ['üë®‚Äçü¶≤', 'üë©', 'üßë‚Äçüéì', 'üßí', 'üë¶', 'üëß', 'üë®', 'üë©‚Äçü¶∞', 'üë±‚Äç‚ôÇÔ∏è', 'üë±‚Äç‚ôÄÔ∏è', 'üßë‚Äçü¶±', 'üë¥', 'üëµ'];

            // Sanitize for display in input value attributes
            const safeMemberName = SecurityUtils.escapeHtml(member.name);
            const safeMemberPassword = SecurityUtils.escapeHtml(member.password);

            return `
                <div class="modal" onclick="handleModalBackdropClick(event)">
                    <div class="modal-content" onclick="event.stopPropagation()">
                        <h3>Edit Family Member</h3>

                        <div class="form-group">
                            <label>Name</label>
                            <input type="text" value="${safeMemberName}" onchange="appState.editingMember.name = this.value" />
                        </div>

                        <div class="form-group">
                            <label>Avatar</label>
                            <div class="avatar-grid">
                                ${avatarOptions.map(avatar => `
                                    <div class="avatar-btn ${member.avatar === avatar ? 'selected' : ''}"
                                         onclick="appState.editingMember.avatar = '${avatar}'; render()">
                                        ${avatar}
                                    </div>
                                `).join('')}
                            </div>
                        </div>

                        <div class="form-row">
                            <div class="form-group">
                                <label>Points</label>
                                <input type="number" value="${member.points}" onchange="appState.editingMember.points = parseInt(this.value) || 0" />
                            </div>
                            <div class="form-group">
                                <label>Role</label>
                                <select onchange="
                                    appState.editingMember.role = this.value;
                                    appState.editingMember.isParent = this.value === 'parent';
                                ">
                                    ${(() => {
                                        const memberRole = member.role || (member.isParent ? 'parent' : 'child');
                                        return `
                                            <option value="parent" ${memberRole === 'parent' ? 'selected' : ''}>Parent</option>
                                            <option value="teen" ${memberRole === 'teen' ? 'selected' : ''}>Teen</option>
                                            <option value="child" ${memberRole === 'child' ? 'selected' : ''}>Child</option>
                                        `;
                                    })()}
                                </select>
                            </div>
                        </div>

                        <div class="form-group">
                            <label>Password</label>
                            <input type="text" value="${safeMemberPassword}" onchange="appState.editingMember.password = this.value" />
                            <small style="color: #6b7280;">User will need this password to login</small>
                        </div>
                        
                        <div class="modal-buttons">
                            <button class="btn btn-success" onclick="saveMember()">üíæ Save</button>
                            <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderConfirmDialog() {
            if (!appState.confirmDialog) return '';
            
            return `
                <div class="modal" onclick="handleModalBackdropClick(event)">
                    <div class="modal-content" style="max-width: 400px;" onclick="event.stopPropagation()">
                        <h3>${appState.confirmDialog.title}</h3>
                        <p style="margin-bottom: 20px;">${appState.confirmDialog.message}</p>
                        
                        <div class="modal-buttons">
                            <button class="btn btn-danger" onclick="appState.confirmDialog.onConfirm()">Delete</button>
                            <button class="btn btn-secondary" onclick="appState.confirmDialog.onCancel()">Cancel</button>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderFloatingTimerPanel() {
            if (appState.activeRewardTimers.length === 0) return '';

            const collapsedClass = appState.timerPanelCollapsed ? 'collapsed' : '';

            return `
                <div id="floating-timer-panel" class="${collapsedClass}">
                    <div class="timer-panel-header" onmousedown="handleTimerPanelDragStart(event)" ontouchstart="handleTimerPanelDragStart(event)">
                        <div class="timer-panel-title">‚è±Ô∏è Active Timers (${appState.activeRewardTimers.length})</div>
                        <div class="timer-panel-controls">
                            <button class="timer-panel-btn" onclick="event.stopPropagation(); toggleTimerPanel()" title="${appState.timerPanelCollapsed ? 'Expand' : 'Collapse'}">
                                ${appState.timerPanelCollapsed ? '‚ñ≤' : '‚ñº'}
                            </button>
                        </div>
                    </div>
                    <div class="timer-panel-body">
                        ${appState.activeRewardTimers.map(timer => {
                            const timeRemaining = formatTimerTime(timer.remainingMs);
                            const user = appState.familyMembers.find(m => m.id === timer.userId);
                            const totalSeconds = Math.ceil(timer.remainingMs / 1000);
                            const totalMinutes = Math.floor(totalSeconds / 60);

                            let timeClass = '';
                            if (totalMinutes < 1) timeClass = 'danger';
                            else if (totalMinutes < 5) timeClass = 'warning';

                            const pausedClass = timer.paused ? 'paused' : '';
                            const collapsedClass = timer.collapsed ? 'collapsed' : '';
                            const activeClass = appState.timerDrawer === timer.id ? 'active' : '';

                            const safeUserName = SecurityUtils.escapeHtml(timer.userName);
                            const safeRewardName = SecurityUtils.escapeHtml(timer.rewardName);

                            if (timer.collapsed) {
                                return `
                                    <div class="timer-card ${pausedClass} ${collapsedClass} ${activeClass}" data-timer-id="${timer.id}">
                                        <div class="timer-card-header" onclick="openTimerDrawer(${timer.id})">
                                            <div class="timer-card-info">
                                                <div class="timer-card-reward">${safeRewardName}</div>
                                            </div>
                                            <div class="timer-card-time ${timeClass}">${timeRemaining}</div>
                                        </div>
                                    </div>
                                `;
                            }

                            // Determine button text and action
                            let controlButton = '';
                            if (!timer.started) {
                                controlButton = `<button class="btn btn-success btn-small" onclick="event.stopPropagation(); startTimer(${timer.id})" style="flex: 1;">‚ñ∂Ô∏è Start</button>`;
                            } else if (timer.paused) {
                                controlButton = `<button class="btn btn-success btn-small" onclick="event.stopPropagation(); resumeTimer(${timer.id})" style="flex: 1;">‚ñ∂Ô∏è Resume</button>`;
                            } else {
                                controlButton = `<button class="btn btn-warning btn-small" onclick="event.stopPropagation(); pauseTimer(${timer.id})" style="flex: 1;">‚è∏Ô∏è Pause</button>`;
                            }

                            return `
                                <div class="timer-card ${pausedClass} ${activeClass}" data-timer-id="${timer.id}">
                                    <div class="timer-card-header" onclick="openTimerDrawer(${timer.id})">
                                        <div class="timer-card-info">
                                            <div class="timer-card-user">${safeUserName}</div>
                                            <div class="timer-card-reward">${safeRewardName}</div>
                                        </div>
                                        <div class="timer-card-time ${timeClass}">${timeRemaining}</div>
                                    </div>
                                    <div class="timer-card-controls">
                                        ${controlButton}
                                        <button class="btn btn-primary btn-small" onclick="event.stopPropagation(); openTimerDrawer(${timer.id})" style="flex: 1;">‚öôÔ∏è Details</button>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;
        }

        function renderTimerDrawer() {
            if (!appState.timerDrawer) return '';

            const timer = appState.activeRewardTimers.find(t => t.id === appState.timerDrawer);
            if (!timer) return '';

            const user = appState.familyMembers.find(m => m.id === timer.userId);
            if (!user) return '';

            const timeRemaining = formatTimerTime(timer.remainingMs);
            const progress = (timer.remainingMs / timer.durationMs) * 100;
            const totalExtendedMinutes = Math.floor(timer.extendedBy / (60 * 1000));

            // SVG circle progress
            const radius = 88;
            const circumference = 2 * Math.PI * radius;
            const offset = circumference - (progress / 100) * circumference;

            const safeUserName = SecurityUtils.escapeHtml(timer.userName);
            const safeRewardName = SecurityUtils.escapeHtml(timer.rewardName);

            return `
                <div id="timer-drawer-overlay" onclick="closeTimerDrawer()"></div>
                <div id="timer-drawer">
                    <div class="timer-drawer-header">
                        <h3>‚è±Ô∏è Timer Details</h3>
                        <button class="timer-drawer-close" onclick="closeTimerDrawer()">‚úï</button>
                    </div>
                    <div class="timer-drawer-body">
                        <div class="timer-progress-ring">
                            <svg width="200" height="200">
                                <circle class="background" cx="100" cy="100" r="${radius}"></circle>
                                <circle class="progress" cx="100" cy="100" r="${radius}"
                                    stroke-dasharray="${circumference}"
                                    stroke-dashoffset="${offset}"></circle>
                            </svg>
                            <div class="timer-center-text">
                                <div class="timer-center-time">${timeRemaining}</div>
                                <div class="timer-center-label">${timer.paused ? 'Paused' : 'Remaining'}</div>
                            </div>
                        </div>

                        <div class="timer-drawer-info">
                            <div class="timer-drawer-info-row">
                                <span class="timer-drawer-info-label">Reward</span>
                                <span class="timer-drawer-info-value">${safeRewardName}</span>
                            </div>
                            <div class="timer-drawer-info-row">
                                <span class="timer-drawer-info-label">User</span>
                                <span class="timer-drawer-info-value">${safeUserName}</span>
                            </div>
                            <div class="timer-drawer-info-row">
                                <span class="timer-drawer-info-label">Duration</span>
                                <span class="timer-drawer-info-value">${timer.timerMinutes || Math.floor(timer.durationMs / 60000)} minutes</span>
                            </div>
                            ${totalExtendedMinutes > 0 ? `
                                <div class="timer-drawer-info-row">
                                    <span class="timer-drawer-info-label">Extended</span>
                                    <span class="timer-drawer-info-value">+${totalExtendedMinutes} minutes</span>
                                </div>
                            ` : ''}
                            <div class="timer-drawer-info-row">
                                <span class="timer-drawer-info-label">Available Points</span>
                                <span class="timer-drawer-info-value">${user.points} pts</span>
                            </div>
                        </div>

                        <div class="timer-drawer-actions">
                            ${!timer.started ? `
                                <button class="btn btn-success" onclick="startTimer(${timer.id})">‚ñ∂Ô∏è Start Timer</button>
                            ` : timer.paused ? `
                                <button class="btn btn-success" onclick="resumeTimer(${timer.id})">‚ñ∂Ô∏è Resume</button>
                            ` : `
                                <button class="btn btn-warning" onclick="pauseTimer(${timer.id})">‚è∏Ô∏è Pause</button>
                            `}
                            <button class="btn btn-primary" onclick="extendTimer(${timer.id})">‚è±Ô∏è Extend</button>
                        </div>

                        <div class="timer-extension-info">
                            üí° Extension: Add ${timer.extensionMinutes} minutes for ${timer.costPerExtension} points
                        </div>
                    </div>
                </div>
            `;
        }

        function renderDashboard() {
            const currentUser = getCurrentUser();
            
            const dailyTasks = appState.tasks.daily;
            const weeklyTasks = appState.tasks.weekly;
            const monthlyTasks = appState.tasks.monthly;
            
            // For counting remaining tasks, only count tasks assigned to current user
            const dailyRemaining = dailyTasks.filter(t => {
                const userCompletion = t.completions[currentUser.id];
                const isAssigned = isTaskAssignedToUser(t, currentUser);
                return isAssigned && (!userCompletion || userCompletion.status !== 'approved');
            }).length;
            
            const weeklyRemaining = weeklyTasks.filter(t => {
                const userCompletion = t.completions[currentUser.id];
                const isAssigned = isTaskAssignedToUser(t, currentUser);
                return isAssigned && (!userCompletion || userCompletion.status !== 'approved');
            }).length;
            
            const monthlyRemaining = monthlyTasks.filter(t => {
                const userCompletion = t.completions[currentUser.id];
                const isAssigned = isTaskAssignedToUser(t, currentUser);
                return isAssigned && (!userCompletion || userCompletion.status !== 'approved');
            }).length;

            return `
                <div class="container">
                    <div class="header">
                        <div class="flex justify-between items-center">
                            <h1>üè† Family Cleaning Tracker</h1>
                            <div class="flex items-center gap-2">
                                <span>${currentUser.avatar} ${SecurityUtils.escapeHtml(currentUser.name)}</span>
                                ${currentUser.isParent ? `
                                    <button class="btn btn-primary" onclick="switchToAdmin()">‚öôÔ∏è Admin</button>
                                ` : ''}
                                <button class="btn btn-secondary" onclick="handleLogout()">Logout</button>
                            </div>
                        </div>
                    </div>

                    ${!currentUser.isParent ? `
                        <div class="points-display">
                            <div>Your Points</div>
                            <div class="points-number">‚≠ê ${currentUser.points}</div>
                        </div>

                        ${(() => {
                            const userPendingRewards = appState.pendingRewards.filter(r => r.userId === currentUser.id && r.status === 'pending');
                            if (userPendingRewards.length > 0) {
                                return `
                                    <div class="admin-panel" style="background: #faf5ff; border: 2px solid #a855f7;">
                                        <h3>‚è≥ Pending Reward Requests</h3>
                                        <div class="item-list" style="max-height: 200px;">
                                            ${userPendingRewards.map(request => {
                                                const safeRewardName = SecurityUtils.escapeHtml(request.rewardName);
                                                return `
                                                    <div class="item-row" style="background: #fef3c7; border-left: 4px solid #f59e0b;">
                                                        <div class="item-info">
                                                            <strong>üéÅ ${safeRewardName}</strong>
                                                            <div class="text-gray">${request.cost} points ‚Ä¢ Waiting for parent approval</div>
                                                            <div style="font-size: 12px; color: #6b7280;">Submitted: ${DateUtils.formatRelative(request.submittedAt)}</div>
                                                        </div>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    </div>
                                `;
                            }
                            return '';
                        })()}

                        <div class="admin-panel">
                            <h3>üéÅ Reward Store</h3>
                            <div class="rewards-grid">
                                ${appState.rewards.map(reward => {
                                    const safeRewardName = SecurityUtils.escapeHtml(reward.name);
                                    const safeRewardCategory = SecurityUtils.escapeHtml(reward.category);
                                    return `
                                        <div class="reward-card ${currentUser.points >= reward.cost ? 'affordable' : ''}"
                                             onclick="redeemReward(${reward.id})">
                                            <div style="font-weight: 500;">${safeRewardName}</div>
                                            <div style="font-size: 14px; color: #6b7280;">${safeRewardCategory}</div>
                                            <span class="reward-cost">${reward.cost} pts</span>
                                            ${currentUser.points < reward.cost ? `
                                                <div style="font-size: 12px; color: #ef4444; margin-top: 5px;">
                                                    Need ${reward.cost - currentUser.points} more points
                                                </div>
                                            ` : ''}
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    ` : ''}

                    <div class="admin-panel">
                        <h2 style="color: #10b981;">üåÖ Today's Tasks (${dailyRemaining} remaining)</h2>
                        <div class="task-grid">
                            ${dailyTasks.map(task => renderTaskCard(task, 'daily')).join('')}
                        </div>
                    </div>

                    <div class="admin-panel">
                        <h2 style="color: #3b82f6;">üìÖ This Week's Tasks (${weeklyRemaining} remaining)</h2>
                        <div class="task-grid">
                            ${weeklyTasks.map(task => renderTaskCard(task, 'weekly')).join('')}
                        </div>
                    </div>

                    <div class="admin-panel">
                        <h2 style="color: #a855f7;">üóìÔ∏è Monthly Deep Clean (${monthlyRemaining} remaining)</h2>
                        <div class="task-grid">
                            ${monthlyTasks.map(task => renderTaskCard(task, 'monthly')).join('')}
                        </div>
                    </div>
                </div>
                
                ${renderTaskEditor()}
                ${renderRewardEditor()}
                ${renderMemberEditor()}
                ${renderConfirmDialog()}
            `;
        }

        function renderAdmin() {
            return `
                <div class="container">
                    <div class="header">
                        <div class="flex justify-between items-center">
                            <h1>‚öôÔ∏è Admin Control Panel</h1>
                            <div class="flex items-center gap-2">
                                <span>${appState.currentUser.avatar} ${SecurityUtils.escapeHtml(appState.currentUser.name)}</span>
                                <button class="btn btn-primary" onclick="switchToUser()">üë§ User View</button>
                                <button class="btn btn-secondary" onclick="handleLogout()">Logout</button>
                            </div>
                        </div>
                    </div>

                    ${renderDataManagement()}

                    <div class="admin-panel">
                        <h3>‚è≥ Pending Task Approvals</h3>
                        ${(() => {
                            const pendingTasks = [];
                            ['daily', 'weekly', 'monthly'].forEach(category => {
                                appState.tasks[category].forEach(task => {
                                    Object.values(task.completions).forEach(completion => {
                                        if (completion.status === 'pending') {
                                            pendingTasks.push({
                                                task,
                                                completion,
                                                category
                                            });
                                        }
                                    });
                                });
                            });

                            const pendingRewards = appState.pendingRewards.filter(r => r.status === 'pending');

                            if (pendingTasks.length === 0 && pendingRewards.length === 0) {
                                return '<p style="color: #6b7280; text-align: center; padding: 20px;">No tasks or rewards pending approval</p>';
                            }

                            return `
                                <div class="item-list">
                                    ${pendingTasks.map(({ task, completion, category }) => {
                                        const safeTaskName = SecurityUtils.escapeHtml(task.name);
                                        const safeCompletionName = SecurityUtils.escapeHtml(completion.name);
                                        return `
                                            <div class="item-row" style="background: #fef3c7; border-left: 4px solid #f59e0b;">
                                                <div class="item-info">
                                                    <strong>${safeTaskName}</strong>
                                                    <div class="text-gray">Submitted by ${safeCompletionName} ‚Ä¢ ${completion.pointsEarned} points${completion.bonusMultiplier && completion.bonusMultiplier > 1.0 ? ` <span class="bonus-badge">üî• ${completion.bonusMultiplier}x streak bonus</span>` : ''}</div>
                                                    <div style="font-size: 12px; color: #6b7280;">Submitted: ${DateUtils.formatRelative(completion.submittedAt)}</div>
                                                </div>
                                                <div class="item-actions">
                                                    <button class="btn btn-success btn-small" onclick="approveTask(${task.id}, '${category}', ${completion.userId})">‚úÖ Approve</button>
                                                    <button class="btn btn-danger btn-small" onclick="
                                                        const reason = prompt('Reason for rejection (optional):', 'Task needs to be redone properly');
                                                        if (reason !== null) rejectTask(${task.id}, '${category}', ${completion.userId}, reason);
                                                    ">‚ùå Reject</button>
                                                </div>
                                            </div>
                                        `;
                                    }).join('')}
                                    ${pendingRewards.map(request => {
                                        const safeRewardName = SecurityUtils.escapeHtml(request.rewardName);
                                        const safeUserName = SecurityUtils.escapeHtml(request.userName);
                                        return `
                                            <div class="item-row" style="background: #faf5ff; border-left: 4px solid #a855f7;">
                                                <div class="item-info">
                                                    <strong>üéÅ ${safeRewardName}</strong>
                                                    <div class="text-gray">Requested by ${safeUserName} ‚Ä¢ ${request.cost} points</div>
                                                    <div style="font-size: 12px; color: #6b7280;">Submitted: ${DateUtils.formatRelative(request.submittedAt)}</div>
                                                </div>
                                                <div class="item-actions">
                                                    <button class="btn btn-success btn-small" onclick="approveReward(${request.id})">‚úÖ Approve</button>
                                                    <button class="btn btn-danger btn-small" onclick="
                                                        const reason = prompt('Reason for rejection (optional):', 'Reward request not approved');
                                                        if (reason !== null) rejectReward(${request.id}, reason);
                                                    ">‚ùå Reject</button>
                                                </div>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            `;
                        })()}
                    </div>

                    <div class="admin-panel">
                        <h3>üîÑ Quick Actions</h3>
                        <div class="admin-actions">
                            <button class="btn btn-primary" onclick="resetTasks('daily')">üîÑ Reset Daily</button>
                            <button class="btn btn-primary" onclick="resetTasks('weekly')">üîÑ Reset Weekly</button>
                            <button class="btn btn-primary" onclick="resetTasks('monthly')">üîÑ Reset Monthly</button>
                            <button class="btn btn-danger" onclick="if(confirm('Reset all points?')) { appState.familyMembers.forEach(m => m.points = 0); showToast('All points reset!', 'success'); autoSave(); safeRender(); }">üîÑ Reset Points</button>
                        </div>
                    </div>

                    <div class="admin-panel">
                        <h3>‚öôÔ∏è Settings</h3>
                        <div class="form-row">
                            <div class="form-group">
                                <label>Point Multiplier</label>
                                <input type="number" step="0.1" value="${appState.settings.pointMultiplier}" 
                                       onblur="appState.settings.pointMultiplier = parseFloat(this.value) || 1.0; autoSave();" />
                                <small style="color: #6b7280;">Multiplies all point values (1.0 = normal, 1.5 = 50% bonus)</small>
                            </div>
                            <div class="form-group">
                                <label>Max Login Attempts</label>
                                <input type="number" value="${appState.settings.maxLoginAttempts}" 
                                       onblur="appState.settings.maxLoginAttempts = parseInt(this.value) || 3; autoSave();" />
                                <small style="color: #6b7280;">Number of failed attempts before lockout</small>
                            </div>
                        </div>
                    </div>

                    <div class="admin-panel">
                        <h3>üìã Task Management</h3>
                        ${['daily', 'weekly', 'monthly'].map(category => `
                            <div style="margin-bottom: 30px;">
                                <div class="section-header">
                                    <h4 style="text-transform: capitalize; margin: 0;">${category} Tasks (${appState.tasks[category].length})</h4>
                                    <button class="btn btn-primary btn-small" onclick="addTask('${category}')">‚ûï Add Task</button>
                                </div>
                                <div class="item-list" style="max-height: 250px;">
                                    ${appState.tasks[category].map((task, idx) => {
                                        const completionCount = Object.values(task.completions || {}).filter(c => c.status === 'approved').length;
                                        const pendingCount = Object.values(task.completions || {}).filter(c => c.status === 'pending').length;
                                        const totalAssigned = task.requiresEveryone ?
                                            appState.familyMembers.filter(m => !m.isParent).length : 1;
                                        const safeTaskName = SecurityUtils.escapeHtml(task.name);
                                        const safeAssignee = SecurityUtils.escapeHtml(task.assignee);
                                        return `
                                            <div class="item-row" draggable="true" data-drag-type="task" data-drag-category="${category}" data-drag-index="${idx}">
                                                <span class="drag-handle" title="Drag to reorder">‚ò∞</span>
                                                <div class="item-info">
                                                    <div style="display: flex; align-items: center; gap: 8px;">
                                                        <strong>${safeTaskName}</strong>
                                                        ${task.requiresEveryone ? '<span style="font-size: 10px; background: #dbeafe; color: #1e40af; padding: 1px 4px; border-radius: 8px;">Individual</span>' : ''}
                                                        ${task.bonusEnabled ? '<span class="bonus-badge" style="font-size: 10px; padding: 1px 5px;">üî• Bonus</span>' : ''}
                                                    </div>
                                                    <div class="text-gray">${safeAssignee} ‚Ä¢ ${Math.round(task.points * appState.settings.pointMultiplier)}pts ‚Ä¢ ${task.timeEstimate}min</div>
                                                    <div class="text-gray">Approved: ${completionCount}/${totalAssigned}${pendingCount > 0 ? ` ‚Ä¢ Pending: ${pendingCount}` : ''}</div>
                                                </div>
                                                <div class="item-actions">
                                                    <button class="btn btn-primary btn-small" onclick="editTask(${JSON.stringify(task).replace(/"/g, '&quot;')})">‚úèÔ∏è Edit</button>
                                                    <button class="btn btn-danger btn-small" onclick="deleteTask(${task.id}, '${category}')">üóëÔ∏è Delete</button>
                                                </div>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            </div>
                        `).join('')}
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div class="admin-panel">
                            <div class="section-header">
                                <h3>üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Family Members (${appState.familyMembers.length})</h3>
                                <button class="btn btn-primary btn-small" onclick="addMember()">‚ûï Add Member</button>
                            </div>
                            <div class="item-list">
                                ${appState.familyMembers.map((member, idx) => {
                                    const role = member.role || (member.isParent ? 'parent' : 'child');
                                    const roleLabel = role.charAt(0).toUpperCase() + role.slice(1);
                                    const safeMemberName = SecurityUtils.escapeHtml(member.name);
                                    const safePassword = SecurityUtils.escapeHtml(member.password);
                                    return `
                                    <div class="item-row" draggable="true" data-drag-type="member" data-drag-index="${idx}">
                                        <span class="drag-handle" title="Drag to reorder">‚ò∞</span>
                                        <div class="item-info">
                                            <div style="display: flex; align-items: center; gap: 8px;">
                                                <span style="font-size: 20px;">${member.avatar}</span>
                                                <strong>${safeMemberName}</strong>
                                            </div>
                                            <div class="text-gray">${member.points} points ‚Ä¢ ${roleLabel}</div>
                                            <div style="font-size: 12px; color: #6b7280; display: flex; align-items: center; gap: 6px;">
                                                <span>Password: ${appState.showMemberPasswords[member.id] ? safePassword : '‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè'}</span>
                                                <span style="cursor: pointer; font-size: 14px; user-select: none;" onclick="toggleMemberPassword(${member.id})" title="${appState.showMemberPasswords[member.id] ? 'Hide password' : 'Show password'}">
                                                    ${appState.showMemberPasswords[member.id] ? 'üôà' : 'üëÅÔ∏è'}
                                                </span>
                                            </div>
                                        </div>
                                        <div class="item-actions">
                                            <button class="btn btn-primary btn-small" onclick="editMember(${JSON.stringify(member).replace(/"/g, '&quot;')})">‚úèÔ∏è Edit</button>
                                            ${appState.familyMembers.length > 1 ? `
                                                <button class="btn btn-danger btn-small" onclick="deleteMember(${member.id})">üóëÔ∏è Delete</button>
                                            ` : ''}
                                        </div>
                                    </div>
                                `}).join('')}
                            </div>
                        </div>

                        <div class="admin-panel">
                            <div class="section-header">
                                <h3>üéÅ Rewards (${appState.rewards.length})</h3>
                                <button class="btn btn-primary btn-small" onclick="addReward()">‚ûï Add Reward</button>
                            </div>
                            <div class="item-list">
                                ${appState.rewards.map((reward, idx) => {
                                    const safeRewardName = SecurityUtils.escapeHtml(reward.name);
                                    const safeRewardCategory = SecurityUtils.escapeHtml(reward.category);
                                    return `
                                        <div class="item-row" draggable="true" data-drag-type="reward" data-drag-index="${idx}">
                                            <span class="drag-handle" title="Drag to reorder">‚ò∞</span>
                                            <div class="item-info">
                                                <strong>${safeRewardName}</strong>
                                                <div class="text-gray">${reward.cost} points ‚Ä¢ ${safeRewardCategory}</div>
                                            </div>
                                            <div class="item-actions">
                                                <button class="btn btn-primary btn-small" onclick="editReward(${JSON.stringify(reward).replace(/"/g, '&quot;')})">‚úèÔ∏è Edit</button>
                                                <button class="btn btn-danger btn-small" onclick="deleteReward(${reward.id})">üóëÔ∏è Delete</button>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    </div>
                </div>
                
                ${renderTaskEditor()}
                ${renderRewardEditor()}
                ${renderMemberEditor()}
                ${renderConfirmDialog()}
            `;
        }

        function render() {
            // Validate session before rendering to prevent stale user data
            if (!validateSession()) {
                return; // Session invalid, logout already handled
            }

            const app = document.getElementById('app');

            if (appState.currentView === 'login') {
                app.innerHTML = renderLogin();
            } else if (appState.currentView === 'admin') {
                app.innerHTML = renderAdmin();
            } else {
                app.innerHTML = renderDashboard();
            }

            // Append timer UI components (outside main app content)
            const existingTimerPanel = document.getElementById('floating-timer-panel');
            const existingTimerDrawer = document.getElementById('timer-drawer');

            // Remove existing timer elements if they exist
            if (existingTimerPanel) existingTimerPanel.remove();
            if (existingTimerDrawer) existingTimerDrawer.parentElement.remove();

            // Add timer components to body (always show if timers are active, even on login screen)
            const timerPanelHTML = renderFloatingTimerPanel();
            const timerDrawerHTML = renderTimerDrawer();

            if (timerPanelHTML) {
                document.body.insertAdjacentHTML('beforeend', timerPanelHTML);

                // Apply saved position if it exists (desktop only)
                if (window.innerWidth >= 768 && appState.timerPanelPosition.x !== null) {
                    setTimeout(() => {
                        const panel = document.getElementById('floating-timer-panel');
                        if (panel) {
                            panel.style.left = appState.timerPanelPosition.x + 'px';
                            panel.style.top = appState.timerPanelPosition.y + 'px';
                            panel.style.right = 'auto';
                            panel.style.bottom = 'auto';
                        }
                    }, 0);
                }
            }
            if (timerDrawerHTML) {
                document.body.insertAdjacentHTML('beforeend', timerDrawerHTML);
            }
        }

        // ===== ERROR BOUNDARIES =====
        function displayRenderError(error) {
            console.error('‚ùå Render Error:', error);
            lastRenderError = error;

            const app = document.getElementById('app');
            const errorMessage = SecurityUtils.escapeHtml(error.message || 'Unknown error');
            const errorStack = SecurityUtils.escapeHtml(error.stack || '');

            app.innerHTML = `
                <div class="login-container" style="max-width: 600px;">
                    <div class="card" style="border: 2px solid #ff6b6b;">
                        <h2 style="color: #ff6b6b;">‚ö†Ô∏è Application Error</h2>
                        <p style="color: #666; margin-bottom: 20px;">
                            Something went wrong while displaying the page. Your data is safe, but the application encountered an unexpected error.
                        </p>

                        <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #ffc107;">
                            <strong>Error Details:</strong>
                            <div style="margin-top: 10px; font-family: monospace; font-size: 12px; color: #333; word-break: break-all;">
                                ${errorMessage}
                            </div>
                        </div>

                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 20px;">
                            <p style="margin: 0; font-size: 14px; color: #666;">
                                <strong>Errors this session:</strong> ${renderErrorCount} / ${MAX_RENDER_ERRORS}
                            </p>
                        </div>

                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <button class="btn btn-primary" onclick="location.reload()" style="flex: 1;">
                                üîÑ Reload Page
                            </button>
                            <button class="btn btn-secondary" onclick="safeReturnToLogin()" style="flex: 1;">
                                üè† Back to Login
                            </button>
                            <button class="btn btn-success" onclick="emergencyExport()" style="flex: 1;">
                                üíæ Export Backup
                            </button>
                        </div>

                        <details style="margin-top: 20px;">
                            <summary style="cursor: pointer; color: #666; font-size: 12px;">Technical Details (for debugging)</summary>
                            <pre style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 11px; overflow-x: auto; max-height: 200px;">${errorStack}</pre>
                        </details>
                    </div>
                </div>
            `;
        }

        function displayCriticalError(error) {
            console.error('‚ùå CRITICAL Error:', error);
            const app = document.getElementById('app');
            const errorMessage = SecurityUtils.escapeHtml(error.message || 'Unknown critical error');

            app.innerHTML = `
                <div class="login-container" style="max-width: 600px;">
                    <div class="card" style="border: 2px solid #dc3545;">
                        <h2 style="color: #dc3545;">üö® Critical Error - Auto Logout</h2>
                        <p style="color: #666; margin-bottom: 20px;">
                            The application encountered ${MAX_RENDER_ERRORS} consecutive errors and will return to the login screen for your safety.
                        </p>

                        <div style="background: #ffe6e6; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #dc3545;">
                            <strong>Last Error:</strong>
                            <div style="margin-top: 10px; font-family: monospace; font-size: 12px; color: #333;">
                                ${errorMessage}
                            </div>
                        </div>

                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <button class="btn btn-primary" onclick="location.reload()" style="flex: 1;">
                                üîÑ Reload & Return to Login
                            </button>
                            <button class="btn btn-success" onclick="emergencyExport()" style="flex: 1;">
                                üíæ Export Backup First
                            </button>
                        </div>

                        <p style="margin-top: 20px; font-size: 12px; color: #999;">
                            If this problem persists, try clearing your browser cache or contact support.
                        </p>
                    </div>
                </div>
            `;
        }

        function safeReturnToLogin() {
            try {
                renderErrorCount = 0;
                lastRenderError = null;
                appState.currentUser = null;
                appState.currentView = 'login';
                safeRender();
            } catch (error) {
                console.error('Error returning to login:', error);
                location.reload();
            }
        }

        function safeRender() {
            try {
                render();
                // Reset error count on successful render
                renderErrorCount = 0;
                lastRenderError = null;
            } catch (error) {
                renderErrorCount++;
                console.error(`Render error ${renderErrorCount}/${MAX_RENDER_ERRORS}:`, error);

                if (renderErrorCount >= MAX_RENDER_ERRORS) {
                    // Critical: Too many errors, force logout
                    console.error('üö® Critical: Maximum render errors reached, forcing logout');
                    appState.currentUser = null;
                    appState.currentView = 'login';
                    displayCriticalError(error);
                } else {
                    // Show recoverable error screen
                    displayRenderError(error);
                }
            }
        }

        // ===== SAFE RENDER WRAPPERS =====
        function safeRenderLogin() {
            try {
                return renderLogin();
            } catch (error) {
                console.error('Error in renderLogin:', error);
                throw error; // Re-throw to be caught by safeRender
            }
        }

        function safeRenderDashboard() {
            try {
                return renderDashboard();
            } catch (error) {
                console.error('Error in renderDashboard:', error);
                throw error; // Re-throw to be caught by safeRender
            }
        }

        function safeRenderAdmin() {
            try {
                return renderAdmin();
            } catch (error) {
                console.error('Error in renderAdmin:', error);
                throw error; // Re-throw to be caught by safeRender
            }
        }

        // Security notice
        console.log('%c? SECURITY NOTICE', 'font-size: 20px; color: red; font-weight: bold;');
        console.log('%cThis is a client-side application. Advanced users can bypass restrictions via browser console.', 'font-size: 14px;');
        console.log('%cFor family use: Parents should monitor browser access.', 'font-size: 14px; color: orange;');

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            // Try to load saved data
            const loaded = loadFromStorage();
            if (loaded) {
                console.log('Loaded saved family data');
            } else {
                console.log('Starting with default family data');
            }

            // Initialize state hash after loading
            stateHash = calculateStateHash();
            hasUnsavedChanges = false;
            console.log('üîë Initial state hash calculated:', stateHash);

            // Initialize reward timer system
            initRewardTimers();
            console.log('‚è±Ô∏è Reward timer system initialized');

            safeRender();
            initDragAndDrop();
        });

        // Save state before page unloads to preserve timer state
        window.addEventListener('beforeunload', function(e) {
            // Save current timer state immediately
            if (appState.activeRewardTimers.length > 0) {
                console.log('üíæ Saving timer state before page unload...');
                saveToStorageInternal();
            }
        });

        // Global ESC key handler for closing modals
        document.addEventListener('keydown', function(e) {
            // ESC key (key code 27)
            if (e.key === 'Escape' || e.keyCode === 27) {
                // Do NOT close confirm dialogs with ESC - they require explicit button click
                if (appState.confirmDialog) {
                    return; // Do nothing for confirm dialogs
                }

                // Close editor modals with confirmation
                if (appState.editingTask || appState.editingReward || appState.editingMember) {
                    if (confirm('Close without saving?')) {
                        closeModal();
                    }
                }
            }
        });

        // Auto-save is now event-driven (triggered after state changes)
        // The old setInterval approach has been removed to prevent race conditions

        // Save before page unload
        window.addEventListener('beforeunload', (e) => {
            if (!appState.settings.autoSave || !appState.currentUser) {
                return;
            }

            // Cancel any pending auto-save
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
                autoSaveTimeout = null;
            }

            // Check if there are actually changes to save
            const currentHash = calculateStateHash();
            if (currentHash === stateHash && !hasUnsavedChanges) {
                console.log('‚è≠Ô∏è Skipping final save (no changes detected)');
                return;
            }

            // Attempt final save, bypassing debounce if needed
            const timeSinceLastSave = Date.now() - lastSaveTimestamp;
            if (timeSinceLastSave >= DEBOUNCE_INTERVAL || lastSaveTimestamp === 0) {
                const result = saveToStorage();
                if (!result.success) {
                    // Show warning if save failed
                    const message = 'Warning: Failed to save your changes!\n\n' + (result.error || 'Unknown error');
                    e.preventDefault();
                    e.returnValue = message;
                    return message;
                } else {
                    // Update hash after successful save
                    stateHash = currentHash;
                    hasUnsavedChanges = false;
                }
            } else {
                // If we saved very recently, no need to save again
                console.log('‚è≠Ô∏è Skipping final save (saved recently)');
            }
        });

        // ===== CROSS-TAB SYNCHRONIZATION =====
        // Listen for storage changes from other tabs
        window.addEventListener('storage', (e) => {
            // Only respond to changes to our storage key
            if (e.key !== STORAGE_KEY) return;

            console.log('üîÑ Detected storage change from another tab, syncing state...');

            // Store current user ID before reloading
            const currentUserId = appState.currentUser ? appState.currentUser.id : null;

            // Reload state from localStorage
            const reloaded = loadFromStorage();

            if (reloaded && currentUserId) {
                // Check if current user still exists after reload
                const userStillExists = appState.familyMembers.find(m => m.id === currentUserId);

                if (!userStillExists) {
                    // Current user was deleted in another tab - force logout
                    console.warn('‚ö†Ô∏è Current user deleted in another tab, forcing logout');
                    alert('‚ö†Ô∏è Your account has been deleted. You will be logged out.');
                    handleLogout();
                    return;
                }

                // Update current user reference with fresh data
                appState.currentUser = userStillExists;
            }

            // Update state hash after syncing from another tab
            stateHash = calculateStateHash();
            hasUnsavedChanges = false;
            console.log('üîë State hash updated after sync from another tab:', stateHash);

            // Re-render with updated state
            safeRender();
        });

        // ===== GLOBAL ERROR HANDLERS =====
        window.addEventListener('error', (event) => {
            console.error('‚ùå Unhandled Error:', event.error);

            // Prevent default browser error handling
            event.preventDefault();

            // Track and handle render-related errors
            if (event.error) {
                renderErrorCount++;

                if (renderErrorCount >= MAX_RENDER_ERRORS) {
                    console.error('üö® Critical: Maximum render errors reached, forcing logout');
                    appState.currentUser = null;
                    appState.currentView = 'login';
                    displayCriticalError(event.error);
                } else {
                    displayRenderError(event.error);
                }
            }

            return true;
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('‚ùå Unhandled Promise Rejection:', event.reason);

            // Prevent default browser error handling
            event.preventDefault();

            // Create error object from rejection reason
            const error = event.reason instanceof Error
                ? event.reason
                : new Error(String(event.reason));

            renderErrorCount++;

            if (renderErrorCount >= MAX_RENDER_ERRORS) {
                console.error('üö® Critical: Maximum render errors reached, forcing logout');
                appState.currentUser = null;
                appState.currentView = 'login';
                displayCriticalError(error);
            } else {
                displayRenderError(error);
            }

            return true;
        });

        // Initial render
        safeRender();
    </script>

    <!-- IndexedDB & Sync Services -->
    <script type="module">
        // Import our local-first services
        import { initDB, addRecord, getRecord, updateRecord, deleteRecord, getAllRecords, queryByIndex, queueSync } from './src/services/db.js';
        import { initSupabase } from './src/services/config.js';
        import { login, register, logout, refreshToken, isAuthenticated, getAuthToken } from './src/services/auth.js';
        import { getSyncManager, initSyncManager, stopSyncManager } from './src/services/sync.js';
        import {
            initMigration,
            resetMigration,
            getFamilyMembers,
            getTasks,
            getRewards,
            saveFamilyMember,
            saveTask,
            saveReward,
            getCurrentFamilyId
        } from './src/services/migration.js';

        // Initialize services on page load
        async function initializeServices() {
            try {
                console.log('üöÄ Initializing FamilyTogether services...');

                // 1. Initialize Supabase
                const supabaseClient = initSupabase();
                if (!supabaseClient) {
                    console.error('‚ùå Failed to initialize Supabase');
                    return false;
                }

                // 2. Initialize IndexedDB
                await initDB();
                console.log('‚úÖ IndexedDB initialized');

                // 3. Migrate localStorage data to IndexedDB (first-time only)
                const migrationResult = await initMigration();
                if (migrationResult.success) {
                    console.log('‚úÖ Migration completed', migrationResult);
                } else {
                    console.warn('‚ö†Ô∏è Migration had issues', migrationResult);
                }

                // 4. Check if user is authenticated
                const authenticated = isAuthenticated();
                if (authenticated) {
                    console.log('‚úÖ User is authenticated, starting sync manager');

                    // 5. Initialize sync manager for authenticated users
                    initSyncManager();
                    startSync();
                } else {
                    console.log('‚ÑπÔ∏è User not authenticated, sync manager not started');
                }

                console.log('‚úÖ All services initialized successfully');
                return true;

            } catch (error) {
                console.error('‚ùå Service initialization failed:', error);
                return false;
            }
        }

        // Initialize services when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeServices);
        } else {
            initializeServices();
        }

        // Expose services to global scope for existing SPA code to use
        window.FamilyTogetherServices = {
            db: { initDB, addRecord, getRecord, updateRecord, deleteRecord, getAllRecords, queryByIndex, queueSync },
            auth: { login, register, logout, refreshToken, isAuthenticated, getAuthToken },
            sync: {
                getSyncManager,
                initSyncManager,
                stopSyncManager,
                // Convenience methods
                forceSync: () => getSyncManager().forceSync(),
                getSyncStatus: () => getSyncManager().getSyncStatus()
            },
            migration: {
                getFamilyMembers,
                getTasks,
                getRewards,
                saveFamilyMember,
                saveTask,
                saveReward,
                getCurrentFamilyId,
                resetMigration  // For testing/debugging
            }
        };

        console.log('üì¶ FamilyTogether services exposed on window.FamilyTogetherServices');

        // Helper functions to bridge between old localStorage code and new IndexedDB
        // These make it easy for the existing code to gradually migrate to IndexedDB

        /**
         * Load data from IndexedDB into appState (async version of loadFromStorage)
         * Call this during app initialization
         */
        async function loadFromIndexedDB() {
            try {
                console.log('üì• Loading data from IndexedDB...');

                // Use migration adapter functions to load data
                const members = await window.FamilyTogetherServices.migration.getFamilyMembers();
                const tasks = await window.FamilyTogetherServices.migration.getTasks();
                const rewards = await window.FamilyTogetherServices.migration.getRewards();

                if (typeof appState !== 'undefined') {
                    appState.familyMembers = members || appState.familyMembers;
                    appState.tasks = tasks || appState.tasks;
                    appState.rewards = rewards || appState.rewards;

                    console.log('‚úÖ Loaded from IndexedDB:', {
                        members: members.length,
                        tasks: tasks.length,
                        rewards: rewards.length
                    });

                    // Trigger UI update if render function exists
                    if (typeof safeRender === 'function') {
                        safeRender();
                    }

                    return true;
                } else {
                    console.warn('‚ö†Ô∏è appState not defined yet, skipping load');
                    return false;
                }
            } catch (error) {
                console.error('‚ùå Failed to load from IndexedDB:', error);
                return false;
            }
        }

        /**
         * Save a family member to IndexedDB
         * @param {Object} member - Member data in old format
         */
        async function saveFamilyMemberToIndexedDB(member) {
            try {
                await window.FamilyTogetherServices.migration.saveFamilyMember(member);
                console.log('‚úÖ Saved family member to IndexedDB:', member.name);
            } catch (error) {
                console.error('‚ùå Failed to save family member:', error);
                throw error;
            }
        }

        /**
         * Save a task to IndexedDB
         * @param {Object} task - Task data in old format
         */
        async function saveTaskToIndexedDB(task) {
            try {
                await window.FamilyTogetherServices.migration.saveTask(task);
                console.log('‚úÖ Saved task to IndexedDB:', task.name);
            } catch (error) {
                console.error('‚ùå Failed to save task:', error);
                throw error;
            }
        }

        /**
         * Save a reward to IndexedDB
         * @param {Object} reward - Reward data in old format
         */
        async function saveRewardToIndexedDB(reward) {
            try {
                await window.FamilyTogetherServices.migration.saveReward(reward);
                console.log('‚úÖ Saved reward to IndexedDB:', reward.name);
            } catch (error) {
                console.error('‚ùå Failed to save reward:', error);
                throw error;
            }
        }

        /**
         * Save all app state to IndexedDB (batch operation)
         * This replaces the old saveToStorage() function
         */
        async function saveAllToIndexedDB() {
            try {
                if (typeof appState === 'undefined') {
                    console.warn('‚ö†Ô∏è appState not defined, skipping save');
                    return { success: false };
                }

                console.log('üíæ Saving all data to IndexedDB...');

                // Save all family members
                if (appState.familyMembers) {
                    for (const member of appState.familyMembers) {
                        await window.FamilyTogetherServices.migration.saveFamilyMember(member);
                    }
                }

                // Save all tasks
                if (appState.tasks) {
                    for (const task of appState.tasks) {
                        await window.FamilyTogetherServices.migration.saveTask(task);
                    }
                }

                // Save all rewards
                if (appState.rewards) {
                    for (const reward of appState.rewards) {
                        await window.FamilyTogetherServices.migration.saveReward(reward);
                    }
                }

                console.log('‚úÖ All data saved to IndexedDB');
                return { success: true };

            } catch (error) {
                console.error('‚ùå Failed to save to IndexedDB:', error);
                return { success: false, error: error.message };
            }
        }

        // Expose helper functions globally for the existing code to use
        window.FamilyTogetherIndexedDB = {
            load: loadFromIndexedDB,
            saveMember: saveFamilyMemberToIndexedDB,
            saveTask: saveTaskToIndexedDB,
            saveReward: saveRewardToIndexedDB,
            saveAll: saveAllToIndexedDB
        };

        console.log('üíæ IndexedDB helper functions exposed on window.FamilyTogetherIndexedDB');

        // Auto-load data from IndexedDB after services are initialized
        // Only load if migration was successful and actually migrated data
        setTimeout(async () => {
            // Check if we have data in IndexedDB before loading
            const stats = await window.FamilyTogetherServices.db.getDBStats();
            const hasData = stats.families > 0 || stats.members > 0 || stats.tasks > 0 || stats.rewards > 0;

            if (hasData) {
                console.log('üìä IndexedDB has data, loading...');
                await loadFromIndexedDB();
            } else {
                console.log('‚ÑπÔ∏è IndexedDB is empty, keeping existing appState');
            }
        }, 1000);
    </script>
</body>
</html>


